#!/usr/bin/env python3
"""
Parallel Python replacement for `spp` using clang subprocess with:
- .clang/.clangd flags support
- Header TU handling
- Parallel processing
- Duplicate removal
"""

import argparse
import subprocess
from pathlib import Path
import tempfile
from concurrent.futures import ThreadPoolExecutor, as_completed
import shlex

# ----------------------------
# Read valid clang flags from .clang/.clangd
# ----------------------------
def read_clang_flags(verbose=False):
    git_root = Path(".").resolve()
    while not (git_root / ".git").exists() and git_root.parent != git_root:
        git_root = git_root.parent
    flags = []

    for file_name in [".clang", ".clangd"]:
        path = git_root / file_name
        if path.exists():
            if verbose:
                print(f"[verbose] Reading clang flags from {path}")
            try:
                text = path.read_text()
                for line in text.splitlines():
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    # Split by spaces
                    for token in shlex.split(line):
                        # Split comma-separated flags
                        subtokens = [t.strip() for t in token.split(",") if t.strip()]
                        for sub in subtokens:
                            # Keep only valid clang CLI flags
                            if sub.startswith("-") and not sub.startswith("--header-insertion") and not sub.startswith("--limit"):
                                flags.append(sub)
            except Exception as e:
                if verbose:
                    print(f"[verbose] Failed reading {path}: {e}")
    return flags

# ----------------------------
# Find files using git grep
# ----------------------------
def git_grep_files(function_name, verbose=False):
    cmd = ["git", "grep", "-l", function_name, "--", "*.cpp", "*.cxx", "*.ixx", "*.cc", "*.h", "*.hpp"]
    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)
    files = result.stdout.strip().splitlines()
    if verbose:
        print(f"[verbose] Found files: {files}")
    return files

# ----------------------------
# Extract function from single file
# ----------------------------
def extract_file(function_name, file, include_dirs, extra_flags, verbose=False):
    path = Path(file)
    if not path.exists():
        if verbose:
            print(f"[verbose] Skipping non-existent file: {file}")
        return ""

    # Handle headers with temporary TU
    if path.suffix in ['.h', '.hpp', '.hh', '.hxx', '.ixx']:
        tu_file = tempfile.NamedTemporaryFile(suffix=".cpp", delete=False)
        tu_file.write(f'#include "{path}"\n'.encode())
        tu_file.close()
        target_file = tu_file.name
        if verbose:
            print(f"[verbose] Created temporary TU: {tu_file.name}")
    else:
        tu_file = None
        target_file = path

    # clang command
    cmd = [
        "clang",
        "-Xclang", f"-ast-dump-filter={function_name}",
        "-fsyntax-only",
        "-Xclang", "-ast-print",
        "-fno-color-diagnostics",
        "-fno-caret-diagnostics",
        "-fno-delayed-template-parsing",
        str(target_file),
        "-std=c++26"
    ] + extra_flags

    for d in include_dirs:
        cmd.extend(["-I", str(d)])

    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")

    output = ""
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.stdout.strip():
            # Strip "Printing ...:" lines
            lines = result.stdout.splitlines()
            filtered = [line for line in lines if not line.startswith("Printing ")]
            if filtered:
                output = "\n".join(filtered)
    except Exception as e:
        if verbose:
            print(f"[verbose] Error running clang on {file}: {e}")

    if tu_file:
        Path(tu_file.name).unlink()

    return output

# ----------------------------
# Parallel extraction and deduplication
# ----------------------------
def extract_function(function_name, files, include_dirs, extra_flags, verbose=False, max_workers=4):
    results = []
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_file = {executor.submit(extract_file, function_name, f, include_dirs, extra_flags, verbose): f for f in files}
        for future in as_completed(future_to_file):
            content = future.result()
            if content:
                results.append(content)

    # Deduplicate blocks by exact string match
    seen_blocks = set()
    final_blocks = []
    for block in results:
        # Split multi-line outputs into blocks by blank lines
        candidate_blocks = [b.strip() for b in block.split("\n\n") if b.strip()]
        for b in candidate_blocks:
            if b not in seen_blocks:
                seen_blocks.add(b)
                final_blocks.append(b)

    if final_blocks:
        print("\n\n".join(final_blocks))

# ----------------------------
# CLI
# ----------------------------
def main():
    parser = argparse.ArgumentParser(description="Extract full C++ function source using clang (parallel, deduplicated)")
    parser.add_argument("function", help="Function name to extract")
    parser.add_argument("files", nargs="*", help="C++ files to search (optional)")
    parser.add_argument("-I", "--include", action="append", default=[], help="Include directories for clang")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    parser.add_argument("--jobs", "-j", type=int, default=4, help="Number of parallel workers")
    args = parser.parse_args()

    files = args.files
    if not files:
        files = git_grep_files(args.function, verbose=args.verbose)
        if not files:
            if args.verbose:
                print(f"[verbose] No files found containing function '{args.function}'")
            return

    extra_flags = read_clang_flags(verbose=args.verbose)
    extract_function(args.function, files, args.include, extra_flags, verbose=args.verbose, max_workers=args.jobs)

if __name__ == "__main__":
    main()

