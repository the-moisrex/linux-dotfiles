#!/usr/bin/env bash
# Subtitle extractor script
# Supports: embedded subtitles, online subtitles via yt-dlp (YouTube, Twitter, Rumble, etc.)
# Features:
# - Auto mode: try embedded first, fallback to online
# - Explicit source selection: embedded, online, auto
# - Flexible language matching: en, eng, English, es, spa, Spanish, etc.
# - Output to stdout or a file
# - Verbose mode

set -euo pipefail

# Script path info
curfile=$(basename "$0")
curdir=$(realpath "$(dirname "$0")")

# Defaults
LANG="eng"
FORMAT="srt"
OUTPUT="-"
VERBOSE=0
SOURCE="auto"  # embedded, online, auto
USE_CACHE=true
CACHE_DISABLED=false

# Check if FORMAT includes .gz compression (e.g., "srt.gz")
COMPRESSION_ENABLED=false
if [[ "$FORMAT" == *.gz ]]; then
    ORIGINAL_FORMAT="${FORMAT%.gz}"
    COMPRESSION_ENABLED=true
    FORMAT="$ORIGINAL_FORMAT"
else
    ORIGINAL_FORMAT="$FORMAT"
fi

# Language mappings
# -------------------------------
# Language mappings (user input → canonical code)
# -------------------------------
declare -A LANG_MAP=(
    ["ab"]="ab" ["aa"]="aa" ["af"]="af" ["ak"]="ak" ["sq"]="sq" ["am"]="am" ["ar"]="ar"
    ["hy"]="hy" ["as"]="as" ["ay"]="ay" ["az"]="az" ["bn"]="bn" ["ba"]="ba" ["eu"]="eu"
    ["be"]="be" ["bho"]="bho" ["bs"]="bs" ["br"]="br" ["bg"]="bg" ["my"]="my" ["ca"]="ca"
    ["ceb"]="ceb" ["zh-Hans"]="zh-Hans" ["zh-hans"]="zh-Hans" ["zh"]="zh-Hans" ["zh-Hant"]="zh-Hant"
    ["zh-hant"]="zh-Hant" ["co"]="co" ["hr"]="hr" ["cs"]="cs" ["da"]="da" ["dv"]="dv"
    ["nl"]="nl" ["dz"]="dz" ["en-orig"]="en" ["en"]="en" ["eo"]="eo" ["et"]="et" ["ee"]="ee"
    ["fo"]="fo" ["fj"]="fj" ["fil"]="fil" ["fi"]="fi" ["fr"]="fra" ["gaa"]="gaa" ["gl"]="gl"
    ["lg"]="lg" ["ka"]="ka" ["de"]="ger" ["el"]="el" ["gn"]="gn" ["gu"]="gu" ["ht"]="ht"
    ["ha"]="ha" ["haw"]="haw" ["iw"]="iw" ["he"]="iw" ["hi"]="hi" ["hmn"]="hmn" ["hu"]="hu"
    ["is"]="is" ["ig"]="ig" ["id"]="id" ["iu"]="iu" ["ga"]="ga" ["it"]="it" ["ja"]="ja"
    ["jv"]="jv" ["kl"]="kl" ["kn"]="kn" ["kk"]="kk" ["kha"]="kha" ["km"]="km" ["rw"]="rw"
    ["ko"]="ko" ["kri"]="kri" ["ku"]="ku" ["ky"]="ky" ["lo"]="lo" ["la"]="la" ["lv"]="lv"
    ["ln"]="ln" ["lt"]="lt" ["lua"]="lua" ["luo"]="luo" ["lb"]="lb" ["mk"]="mk" ["mg"]="mg"
    ["ms"]="ms" ["ml"]="ml" ["mt"]="mt" ["gv"]="gv" ["mi"]="mi" ["mr"]="mr" ["mn"]="mn"
    ["mfe"]="mfe" ["ne"]="ne" ["new"]="new" ["nso"]="nso" ["no"]="no" ["ny"]="ny" ["oc"]="oc"
    ["or"]="or" ["om"]="om" ["os"]="os" ["pam"]="pam" ["ps"]="ps" ["fa"]="fas" ["pl"]="pl"
    ["pt"]="pt" ["pt-PT"]="pt-PT" ["pa"]="pa" ["qu"]="qu" ["ro"]="ro" ["rn"]="rn" ["ru"]="ru"
    ["sm"]="sm" ["sg"]="sg" ["sa"]="sa" ["gd"]="gd" ["sr"]="sr" ["crs"]="crs" ["sn"]="sn"
    ["sd"]="sd" ["si"]="si" ["sk"]="sk" ["sl"]="sl" ["so"]="so" ["st"]="st" ["es"]="spa"
    ["su"]="su" ["sw"]="sw" ["ss"]="ss" ["sv"]="sv" ["tg"]="tg" ["ta"]="ta" ["tt"]="tt"
    ["te"]="te" ["th"]="th" ["bo"]="bo" ["ti"]="ti" ["to"]="to" ["ts"]="ts" ["tn"]="tn"
    ["tum"]="tum" ["tr"]="tr" ["tk"]="tk" ["uk"]="uk" ["ur"]="ur" ["ug"]="ug" ["uz"]="uz"
    ["ve"]="ve" ["vi"]="vi" ["war"]="war" ["cy"]="cy" ["fy"]="fy" ["wo"]="wo" ["xh"]="xh"
    ["yi"]="yi" ["yo"]="yo" ["zu"]="zu"
)

# -------------------------------
# Aliases for ffmpeg/ffprobe stream matching
# -------------------------------
declare -A LANG_ALIASES=(
    ["eng"]="en eng english"
    ["spa"]="es spa spanish"
    ["fas"]="fa fas farsi persian"
    ["fra"]="fr fra french"
    ["ger"]="de ger german"
    ["zh-Hans"]="zh zh-Hans chinese chinese-simplified"
    ["zh-Hant"]="zh-Hant chinese-traditional"
    ["ab"]="ab"
    ["aa"]="aa"
    ["af"]="af"
    ["ak"]="ak"
    ["sq"]="sq"
    ["am"]="am"
    ["ar"]="ar"
    ["hy"]="hy"
    ["as"]="as"
    ["ay"]="ay"
    ["az"]="az"
    ["bn"]="bn"
    ["ba"]="ba"
    ["eu"]="eu"
    ["be"]="be"
    ["bho"]="bho"
    ["bs"]="bs"
    ["br"]="br"
    ["bg"]="bg"
    ["my"]="my"
    ["ca"]="ca"
    ["ceb"]="ceb"
    ["co"]="co"
    ["hr"]="hr"
    ["cs"]="cs"
    ["da"]="da"
    ["dv"]="dv"
    ["nl"]="nl"
    ["dz"]="dz"
    ["en-orig"]="en en-orig english"
    ["eo"]="eo"
    ["et"]="et"
    ["ee"]="ee"
    ["fo"]="fo"
    ["fj"]="fj"
    ["fil"]="fil filipino"
    ["fi"]="fi"
    ["gaa"]="gaa"
    ["gl"]="gl"
    ["lg"]="lg"
    ["ka"]="ka"
    ["el"]="el greek"
    ["gn"]="gn"
    ["gu"]="gu"
    ["ht"]="ht"
    ["ha"]="ha"
    ["haw"]="haw"
    ["iw"]="iw hebrew"
    ["he"]="iw hebrew"
    ["hi"]="hi hindi"
    ["hmn"]="hmn"
    ["hu"]="hu"
    ["is"]="is"
    ["ig"]="ig"
    ["id"]="id indonesian"
    ["iu"]="iu"
    ["ga"]="ga irish"
    ["it"]="it italian"
    ["ja"]="ja japanese"
    ["jv"]="jv"
    ["kl"]="kl"
    ["kn"]="kn"
    ["kk"]="kk"
    ["kha"]="kha"
    ["km"]="km"
    ["rw"]="rw"
    ["ko"]="ko korean"
    ["kri"]="kri"
    ["ku"]="ku"
    ["ky"]="ky"
    ["lo"]="lo"
    ["la"]="la latin"
    ["lv"]="lv"
    ["ln"]="ln"
    ["lt"]="lt"
    ["lua"]="lua"
    ["luo"]="luo"
    ["lb"]="lb"
    ["mk"]="mk"
    ["mg"]="mg"
    ["ms"]="ms"
    ["ml"]="ml"
    ["mt"]="mt"
    ["gv"]="gv"
    ["mi"]="mi maori"
    ["mr"]="mr"
    ["mn"]="mn"
    ["mfe"]="mfe"
    ["ne"]="ne"
    ["new"]="new"
    ["nso"]="nso"
    ["no"]="no norwegian"
    ["ny"]="ny"
    ["oc"]="oc"
    ["or"]="or"
    ["om"]="om"
    ["os"]="os"
    ["pam"]="pam"
    ["ps"]="ps"
    ["pl"]="pl"
    ["pt"]="pt portuguese"
    ["pt-PT"]="pt-PT portuguese-portugal"
    ["pa"]="pa punjabi"
    ["qu"]="qu"
    ["ro"]="ro"
    ["rn"]="rn"
    ["ru"]="ru russian"
    ["sm"]="sm"
    ["sg"]="sg"
    ["sa"]="sa"
    ["gd"]="gd"
    ["sr"]="sr"
    ["crs"]="crs"
    ["sn"]="sn"
    ["sd"]="sd"
    ["si"]="si"
    ["sk"]="sk"
    ["sl"]="sl"
    ["so"]="so"
    ["st"]="st"
    ["su"]="su"
    ["sw"]="sw"
    ["ss"]="ss"
    ["sv"]="sv"
    ["tg"]="tg"
    ["ta"]="ta"
    ["tt"]="tt"
    ["te"]="te"
    ["th"]="th"
    ["bo"]="bo"
    ["ti"]="ti"
    ["to"]="to"
    ["ts"]="ts"
    ["tn"]="tn"
    ["tum"]="tum"
    ["tr"]="tr"
    ["tk"]="tk"
    ["uk"]="uk"
    ["ur"]="ur"
    ["ug"]="ug"
    ["uz"]="uz"
    ["ve"]="ve"
    ["vi"]="vi"
    ["war"]="war"
    ["cy"]="cy"
    ["fy"]="fy"
    ["wo"]="wo"
    ["xh"]="xh"
    ["yi"]="yi"
    ["yo"]="yo"
    ["zu"]="zu"
)

# -------------------------------
# yt-dlp language codes (canonical → yt-dlp expected)
# -------------------------------
declare -A YT_LANG_MAP=(
    ["eng"]="en"
    ["spa"]="es"
    ["fas"]="fa"
    ["fra"]="fr"
    ["ger"]="de"
    ["zh-Hans"]="zh-CN"
    ["zh-Hant"]="zh-TW"
    ["ab"]="ab"
    ["aa"]="aa"
    ["af"]="af"
    ["ak"]="ak"
    ["sq"]="sq"
    ["am"]="am"
    ["ar"]="ar"
    ["hy"]="hy"
    ["as"]="as"
    ["ay"]="ay"
    ["az"]="az"
    ["bn"]="bn"
    ["ba"]="ba"
    ["eu"]="eu"
    ["be"]="be"
    ["bho"]="bho"
    ["bs"]="bs"
    ["br"]="br"
    ["bg"]="bg"
    ["my"]="my"
    ["ca"]="ca"
    ["ceb"]="ceb"
    ["co"]="co"
    ["hr"]="hr"
    ["cs"]="cs"
    ["da"]="da"
    ["dv"]="dv"
    ["nl"]="nl"
    ["dz"]="dz"
    ["en-orig"]="en"
    ["eo"]="eo"
    ["et"]="et"
    ["ee"]="ee"
    ["fo"]="fo"
    ["fj"]="fj"
    ["fil"]="fil"
    ["fi"]="fi"
    ["gaa"]="gaa"
    ["gl"]="gl"
    ["lg"]="lg"
    ["ka"]="ka"
    ["el"]="el"
    ["gn"]="gn"
    ["gu"]="gu"
    ["ht"]="ht"
    ["ha"]="ha"
    ["haw"]="haw"
    ["iw"]="he"
    ["hi"]="hi"
    ["hmn"]="hmn"
    ["hu"]="hu"
    ["is"]="is"
    ["ig"]="ig"
    ["id"]="id"
    ["iu"]="iu"
    ["ga"]="ga"
    ["it"]="it"
    ["ja"]="ja"
    ["jv"]="jv"
    ["kl"]="kl"
    ["kn"]="kn"
    ["kk"]="kk"
    ["kha"]="kha"
    ["km"]="km"
    ["rw"]="rw"
    ["ko"]="ko"
    ["kri"]="kri"
    ["ku"]="ku"
    ["ky"]="ky"
    ["lo"]="lo"
    ["la"]="la"
    ["lv"]="lv"
    ["ln"]="ln"
    ["lt"]="lt"
    ["lua"]="lua"
    ["luo"]="luo"
    ["lb"]="lb"
    ["mk"]="mk"
    ["mg"]="mg"
    ["ms"]="ms"
    ["ml"]="ml"
    ["mt"]="mt"
    ["gv"]="gv"
    ["mi"]="mi"
    ["mr"]="mr"
    ["mn"]="mn"
    ["mfe"]="mfe"
    ["ne"]="ne"
    ["new"]="new"
    ["nso"]="nso"
    ["no"]="no"
    ["ny"]="ny"
    ["oc"]="oc"
    ["or"]="or"
    ["om"]="om"
    ["os"]="os"
    ["pam"]="pam"
    ["ps"]="ps"
    ["pl"]="pl"
    ["pt"]="pt"
    ["pt-PT"]="pt-PT"
    ["pa"]="pa"
    ["qu"]="qu"
    ["ro"]="ro"
    ["rn"]="rn"
    ["ru"]="ru"
    ["sm"]="sm"
    ["sg"]="sg"
    ["sa"]="sa"
    ["gd"]="gd"
    ["sr"]="sr"
    ["crs"]="crs"
    ["sn"]="sn"
    ["sd"]="sd"
    ["si"]="si"
    ["sk"]="sk"
    ["sl"]="sl"
    ["so"]="so"
    ["st"]="st"
    ["su"]="su"
    ["sw"]="sw"
    ["ss"]="ss"
    ["sv"]="sv"
    ["tg"]="tg"
    ["ta"]="ta"
    ["tt"]="tt"
    ["te"]="te"
    ["th"]="th"
    ["bo"]="bo"
    ["ti"]="ti"
    ["to"]="to"
    ["ts"]="ts"
    ["tn"]="tn"
    ["tum"]="tum"
    ["tr"]="tr"
    ["tk"]="tk"
    ["uk"]="uk"
    ["ur"]="ur"
    ["ug"]="ug"
    ["uz"]="uz"
    ["ve"]="ve"
    ["vi"]="vi"
    ["war"]="war"
    ["cy"]="cy"
    ["fy"]="fy"
    ["wo"]="wo"
    ["xh"]="xh"
    ["yi"]="yi"
    ["yo"]="yo"
    ["zu"]="zu"
)

# -------------------------------
# Browsers to try with --cookies-from-browser if yt-dlp fails normally
# -------------------------------
BROWSERS_TO_TRY=("firefox" "vivaldi")



# -------------------------------
# Usage / help function
# -------------------------------
usage() {
    cat <<EOF
Usage: $curfile [options] <file_or_url>...

Options:
  -l, --lang <code>       Subtitle language (default: en, e.g., en, eng, English)
  -f, --format <fmt>      Subtitle format (default: srt, supports compressed formats like srt.gz)
  -o, --output <file>     Output file (default: stdout)
  -v, --verbose           Enable verbose output
  -s, --source <src>      Subtitle source: embedded, online, auto (default: auto)
  --cache                 Enable caching to default directory (\${XDG_CONFIG_HOME:-\$HOME/.config}/youtube-subtitles/VIDEOID.LANG.FORMAT)
  --no-cache              Disable caching (overrides --cache)
  -h, --help              Show this help message

Examples:
  $curfile video.mp4
  $curfile -l es -f vtt -o subs.vtt https://youtube.com/watch?v=xyz
  $curfile -l en -f srt.gz -o subs.srt.gz https://youtube.com/watch?v=xyz  # Compressed output
  $curfile myfile.mp4 -s auto
  $curfile --cache https://youtube.com/watch?v=xyz    # Caches to default directory
  $curfile --no-cache https://youtube.com/watch?v=xyz # Disables caching
EOF
    exit 0
}

# -------------------------------
# Logging helper
# -------------------------------
log() { [[ $VERBOSE -eq 1 ]] && echo "[INFO] $*" >&2; }

# -------------------------------
# Normalize language codes
# -------------------------------
normalize_lang() {
    local input_lang="${1,,}"
    echo "${LANG_MAP[$input_lang]:-$input_lang}"
}

# Generate aliases for matching streams
get_lang_aliases() {
    local lang="$1"
    echo "${LANG_ALIASES[$lang]:-$lang}"
}

# Convert language code for yt-dlp
to_yt_lang() {
    echo "${YT_LANG_MAP[$1]:-$1}"
}

# Check if cached subtitle exists
cache_exists() {
    local url="$1"

    # Extract video ID
    local video_id
    video_id=$(get_youtube_id "$url")
    if [[ -z "$video_id" ]]; then
        log "Could not extract YouTube video ID from URL: $url"
        return 1
    fi

    # Set up the output directory
    local subtitles_dir="${XDG_CONFIG_HOME:-$HOME/.config}/youtube-subtitles"

    # Create the cached filename (with compression extension if enabled)
    local cached_file="$subtitles_dir/$video_id.$LANG.$ORIGINAL_FORMAT"

    # Check priority depends on COMPRESSION_ENABLED setting:
    # If compression is enabled, check for .gz file first, then uncompressed
    # If compression is disabled, check for uncompressed file first, then .gz
    if [[ "$COMPRESSION_ENABLED" == "true" ]]; then
        if [[ -f "${cached_file}.gz" ]]; then
            log "Cached compressed subtitle found: ${cached_file}.gz"
            echo "${cached_file}.gz"
            return 0
        elif [[ -f "$cached_file" ]]; then
            log "Cached subtitle found: $cached_file"
            echo "$cached_file"
            return 0
        else
            log "No cached subtitle found for: $video_id"
            return 1
        fi
    else
        if [[ -f "$cached_file" ]]; then
            log "Cached subtitle found: $cached_file"
            echo "$cached_file"
            return 0
        elif [[ -f "${cached_file}.gz" ]]; then
            log "Cached compressed subtitle found: ${cached_file}.gz"
            echo "${cached_file}.gz"
            return 0
        else
            log "No cached subtitle found for: $video_id"
            return 1
        fi
    fi
}

# Extract YouTube video ID from URL and save to default directory
save_to_default_dir() {
    local url="$1"
    local subs_content="$2"

    # Extract video ID
    local video_id
    video_id=$(get_youtube_id "$url")
    if [[ -z "$video_id" ]]; then
        log "Could not extract YouTube video ID from URL: $url"
        return 1
    fi

    # Set up the output directory
    local subtitles_dir="${XDG_CONFIG_HOME:-$HOME/.config}/youtube-subtitles"
    mkdir -p "$subtitles_dir"

    # Create the output filename (with compression extension if enabled)
    local output_file="$subtitles_dir/$video_id.$LANG.$ORIGINAL_FORMAT"

    # Write the subtitle content to the file (compress if needed)
    if [[ "$COMPRESSION_ENABLED" == "true" ]]; then
        # Write to temporary file first, then compress
        local temp_file=$(mktemp)
        echo "$subs_content" > "$temp_file"
        compress_file "$temp_file" "${output_file}.gz"
        rm -f "$temp_file"
        log "Compressed subtitles saved to: ${output_file}.gz"
    else
        # Write uncompressed
        echo "$subs_content" > "$output_file"
        log "Subtitles saved to: $output_file"
    fi

    return 0
}

# Execute yt-dlp with given options and handle output
execute_yt_dlp() {
    local opts=("$@")
    
    if [[ $VERBOSE -eq 0 ]]; then
        if yt-dlp "${opts[@]}" >/dev/null 2>&1; then
            return 0
        else
            return 1
        fi
    else
        if yt-dlp "${opts[@]}"; then
            return 0
        else
            return 1
        fi
    fi
}

# Extract YouTube video ID from URL
get_youtube_id() {
    local url="$1"
    # Various YouTube URL patterns
    if [[ "$url" =~ ^https?://[^/]*youtube\.com/watch\?v=([a-zA-Z0-9_-]{11}) ]]; then
        echo "${BASH_REMATCH[1]}"
    elif [[ "$url" =~ ^https?://youtu\.be/([a-zA-Z0-9_-]{11}) ]]; then
        echo "${BASH_REMATCH[1]}"
    elif [[ "$url" =~ ^https?://[^/]*youtube\.com/embed/([a-zA-Z0-9_-]{11}) ]]; then
        echo "${BASH_REMATCH[1]}"
    elif [[ "$url" =~ ^https?://[^/]*youtube\.com/v/([a-zA-Z0-9_-]{11}) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        return 1
    fi
}

# -------------------------------
# Argument parsing
# -------------------------------
ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -l|--lang) LANG=$(normalize_lang "$2"); shift 2 ;;
        -f|--format)
            FORMAT="$2"
            # Check if FORMAT includes .gz compression (e.g., "srt.gz")
            if [[ "$FORMAT" == *.gz ]]; then
                ORIGINAL_FORMAT="${FORMAT%.gz}"
                COMPRESSION_ENABLED=true
                FORMAT="$ORIGINAL_FORMAT"
            else
                ORIGINAL_FORMAT="$FORMAT"
                COMPRESSION_ENABLED=false
            fi
            shift 2
            ;;
        -o|--output) OUTPUT="$2"; shift 2 ;;
        -v|--verbose) VERBOSE=1; shift ;;
        -s|--source) SOURCE="$2"; shift 2 ;;
        --cache) USE_CACHE=true; CACHE_DISABLED=false; shift ;;
        --no-cache) CACHE_DISABLED=true; USE_CACHE=false; shift ;;
        -h|--help) usage ;;
        -*)
            echo "Unknown option: $1" >&2
            usage
        ;;
        *) ARGS+=("$1"); shift ;;
    esac
done

[[ ${#ARGS[@]} -eq 0 ]] && { echo "Error: no input files or URLs specified" >&2; usage; }

# -------------------------------
# Compression/Decompression functions
# -------------------------------
compress_file() {
    local input_file="$1"
    local output_file="$2"
    if command -v gzip >/dev/null 2>&1; then
        gzip -c "$input_file" > "$output_file"
    else
        echo "Error: gzip command not found" >&2
        return 1
    fi
}

decompress_file() {
    local input_file="$1"
    local output_file="$2"
    if command -v gunzip >/dev/null 2>&1; then
        gunzip -c "$input_file" > "$output_file"
    else
        echo "Error: gunzip command not found" >&2
        return 1
    fi
}

# -------------------------------
# Extract embedded subtitles
# -------------------------------
extract_embedded_subs() {
    local file="$1"
    local url="${2:-}"  # Optional URL parameter to support saving to default directory
    log "Checking embedded subtitles for $file (lang=$LANG)..."

    # Check cache first if caching is enabled and we have a URL
    if [[ -n "$url" && "$USE_CACHE" == "true" && "$CACHE_DISABLED" == "false" ]]; then
        local cached_file
        cached_file=$(cache_exists "$url")
        if [[ -n "$cached_file" && -f "$cached_file" ]]; then
            # Cache exists, use it
            local cached_content
            if [[ "$cached_file" == *.gz ]]; then
                # Decompress the cached file if it has .gz extension
                local temp_decompressed=$(mktemp)
                decompress_file "$cached_file" "$temp_decompressed"
                cached_content=$(cat "$temp_decompressed")
                rm -f "$temp_decompressed"
            else
                # Read uncompressed file
                cached_content=$(cat "$cached_file")
            fi

            # Handle output
            if [[ "$OUTPUT" == "-" ]]; then
                # Output to stdout
                echo "$cached_content"
            else
                # Save to specified file (with compression if needed)
                if [[ "$COMPRESSION_ENABLED" == "true" && "$ORIGINAL_FORMAT" != "gz" ]]; then
                    # Compress the output file
                    local temp_file=$(mktemp)
                    echo "$cached_content" > "$temp_file"
                    compress_file "$temp_file" "$OUTPUT"
                    rm -f "$temp_file"
                    log "Compressed subtitles saved to: $OUTPUT"
                else
                    # Save uncompressed
                    echo "$cached_content" > "$OUTPUT"
                    log "Subtitles saved to: $OUTPUT"
                fi
            fi
            return 0
        fi
    fi

    # Get subtitle stream indices matching language aliases
    local aliases=($(get_lang_aliases "$LANG"))
    local index
    index=$(ffprobe -v error -select_streams s \
        -show_entries stream=index:stream_tags=language \
        -of json "$file" | jq -r --argjson aliases "$(printf '["%s"]' "${aliases[*]}" | sed 's/ /","/g')" '
    .streams[] | select( .tags.language | ascii_downcase as $t | $aliases[] | test($t; "i") ) | .index' | head -n1)

    if [[ -n "$index" ]]; then
        log "Found embedded subtitles (stream index $index), extracting..."

        # Get the subtitle stream index among all subtitle streams
        local subtitle_index=$(ffprobe -v error -select_streams s -show_entries stream=index -of csv=p=0 "$file" | \
        tr ',' '\n' | grep -n "^$index$" | cut -d: -f1)
        subtitle_index=$((subtitle_index - 1))  # Convert to 0-based index

        log "Using subtitle stream index: $subtitle_index (absolute index: $index)"

        # Use a temporary file with proper extension
        local tmpfile=$(mktemp --suffix=".$FORMAT")

        # Extract to temporary file
        ffmpeg -hide_banner -loglevel error -y -i "$file" -map 0:s:$subtitle_index "$tmpfile"

        # Read the subtitle content
        local sub_content=$(cat "$tmpfile")

        # If cache is enabled and we have a URL, save to default directory
        if [[ -n "$url" && "$USE_CACHE" == "true" && "$CACHE_DISABLED" == "false" ]]; then
            save_to_default_dir "$url" "$sub_content"
        fi

        # Handle output
        if [[ "$OUTPUT" == "-" ]]; then
            # Output to stdout
            echo "$sub_content"
        else
            # Save to specified file (with compression if needed)
            if [[ "$COMPRESSION_ENABLED" == "true" ]]; then
                # Compress the output file
                local temp_file=$(mktemp)
                echo "$sub_content" > "$temp_file"
                compress_file "$temp_file" "$OUTPUT"
                rm -f "$temp_file"
                log "Compressed subtitles saved to: $OUTPUT"
            else
                # Save uncompressed
                echo "$sub_content" > "$OUTPUT"
                log "Subtitles saved to: $OUTPUT"
            fi
        fi

        # Clean up
        rm -f "$tmpfile"
        return 0
    else
        log "No embedded subtitles found for $LANG."
        return 1
    fi
}

# -------------------------------
# Get subtitles from online URL with youtube_transcript_api fallback
# -------------------------------
get_subs_from_url() {
    local url="$1"
    log "Downloading subtitles from URL: $url"

    # Check cache first if caching is enabled
    if [[ "$USE_CACHE" == "true" && "$CACHE_DISABLED" == "false" ]]; then
        local cached_file
        cached_file=$(cache_exists "$url")
        if [[ -n "$cached_file" && -f "$cached_file" ]]; then
            # Cache exists, use it
            local cached_content
            if [[ "$cached_file" == *.gz ]]; then
                # Decompress the cached file if it has .gz extension
                local temp_decompressed=$(mktemp)
                decompress_file "$cached_file" "$temp_decompressed"
                cached_content=$(cat "$temp_decompressed")
                rm -f "$temp_decompressed"
            else
                # Read uncompressed file
                cached_content=$(cat "$cached_file")
            fi

            # Handle output
            if [[ "$OUTPUT" == "-" ]]; then
                # Output to stdout
                echo "$cached_content"
            else
                # Save to specified file (with compression if needed)
                if [[ "$COMPRESSION_ENABLED" == "true" && "$ORIGINAL_FORMAT" != "gz" ]]; then
                    # Compress the output file
                    local temp_file=$(mktemp)
                    echo "$cached_content" > "$temp_file"
                    compress_file "$temp_file" "$OUTPUT"
                    rm -f "$temp_file"
                    log "Compressed subtitles saved to: $OUTPUT"
                else
                    # Save uncompressed
                    echo "$cached_content" > "$OUTPUT"
                    log "Subtitles saved to: $OUTPUT"
                fi
            fi
            return 0
        fi
    fi

    # First, try yt-dlp
    local tmpdir=$(mktemp -d)
    local yt_lang=$(to_yt_lang "$LANG")
    local opts=(--skip-download --sub-lang "$yt_lang-orig,$yt_lang" --write-auto-sub --convert-subs "$FORMAT" --sub-format "$FORMAT")
    opts+=(-o "$tmpdir/subtitles.%(ext)s" "$url")

    local sub_content=""

    # Download to temporary directory with yt-dlp
    if execute_yt_dlp "${opts[@]}"; then
        # yt-dlp succeeded, continue with the existing logic
        # Find the downloaded subtitle file
        local subfile=$(find "$tmpdir" -name "*.${FORMAT}" | head -n1)

        if [[ -f "$subfile" ]]; then
            # Read the subtitle content
            sub_content=$(cat "$subfile")

            # If cache is enabled, save to default directory
            if [[ "$USE_CACHE" == "true" && "$CACHE_DISABLED" == "false" ]]; then
                save_to_default_dir "$url" "$sub_content"
            fi

            # Handle output (print to stdout or save to specified file)
            if [[ "$OUTPUT" == "-" ]]; then
                # Output to stdout
                echo "$sub_content"
            else
                # Save to specified file (with compression if needed)
                if [[ "$COMPRESSION_ENABLED" == "true" ]]; then
                    # Compress the output file
                    local temp_file=$(mktemp)
                    echo "$sub_content" > "$temp_file"
                    compress_file "$temp_file" "$OUTPUT"
                    rm -f "$temp_file"
                    log "Compressed subtitles saved to: $OUTPUT"
                else
                    # Save uncompressed
                    echo "$sub_content" > "$OUTPUT"
                    log "Subtitles saved to: $OUTPUT"
                fi
            fi
            rm -rf "$tmpdir"
            return 0
        fi
    fi

    log "yt-dlp failed, trying with --cookies-from-browser option..."

    # If initial yt-dlp command failed, try with --cookies-from-browser for each browser
    local browser
    for browser in "${BROWSERS_TO_TRY[@]}"; do
        log "Trying yt-dlp with --cookies-from-browser=$browser"

        local cookie_opts=("${opts[@]}" --cookies-from-browser "$browser")

        if execute_yt_dlp "${cookie_opts[@]}"; then
            # yt-dlp with cookies succeeded
            local subfile=$(find "$tmpdir" -name "*.${FORMAT}" | head -n1)

            if [[ -f "$subfile" ]]; then
                # Read the subtitle content
                sub_content=$(cat "$subfile")

                # If cache is enabled, save to default directory
                if [[ "$USE_CACHE" == "true" && "$CACHE_DISABLED" == "false" ]]; then
                    save_to_default_dir "$url" "$sub_content"
                fi

                # Handle output (print to stdout or save to specified file)
                if [[ "$OUTPUT" == "-" ]]; then
                    # Output to stdout
                    echo "$sub_content"
                else
                    # Save to specified file (with compression if needed)
                    if [[ "$COMPRESSION_ENABLED" == "true" ]]; then
                        # Compress the output file
                        local temp_file=$(mktemp)
                        echo "$sub_content" > "$temp_file"
                        compress_file "$temp_file" "$OUTPUT"
                        rm -f "$temp_file"
                        log "Compressed subtitles saved to: $OUTPUT"
                    else
                        # Save uncompressed
                        echo "$sub_content" > "$OUTPUT"
                        log "Subtitles saved to: $OUTPUT"
                    fi
                fi
                rm -rf "$tmpdir"
                return 0
            fi
        fi
    done

    log "yt-dlp with --cookies-from-browser failed, trying youtube_transcript_api as fallback..."

    # All yt-dlp attempts failed, try youtube_transcript_api as fallback
    if command -v youtube_transcript_api >/dev/null 2>&1; then
        log "youtube_transcript_api is available, using it as fallback"

        # Extract video ID from URL
        local video_id
        video_id=$(get_youtube_id "$url")
        if [[ -z "$video_id" ]]; then
            log "Could not extract YouTube video ID from URL: $url"
            rm -rf "$tmpdir"
            return 1
        fi

        # Format mapping for youtube_transcript_api
        local yt_api_format="$FORMAT"
        case "$FORMAT" in
            "srt") yt_api_format="srt" ;;
            "vtt"|"webvtt") yt_api_format="webvtt" ;;
            "txt") yt_api_format="text" ;;
            "json") yt_api_format="json" ;;
            "pretty") yt_api_format="pretty" ;;
            *) yt_api_format="srt" ;;  # default to srt
        esac

        # Try to get subtitles using youtube_transcript_api CLI
        # Map our language code to standard 2-letter code for youtube_transcript_api
        local api_lang="$yt_lang"
        case "$yt_lang" in
            "ger") api_lang="de" ;;
            "fra") api_lang="fr" ;;
            "spa") api_lang="es" ;;
            "eng") api_lang="en" ;;
            "zh-Hans") api_lang="zh-CN" ;;
            "zh-Hant") api_lang="zh-TW" ;;
            "fas") api_lang="fa" ;;
        esac

        # Try with the CLI and capture output and exit code
        local api_output
        api_output=$(youtube_transcript_api --languages "$api_lang" --format "$yt_api_format" "$video_id" 2>&1)
        local api_exit_code=$?

        # The CLI sometimes returns 0 exit code even when it fails, so we need to check the output
        if [[ $api_exit_code -eq 0 && -n "$api_output" && ! "$api_output" =~ "Could not retrieve a transcript" && ! "$api_output" =~ "This is most likely caused by:" ]]; then
            # Success (no error message in output)
            sub_content="$api_output"

            # If cache is enabled, save to default directory
            if [[ "$USE_CACHE" == "true" && "$CACHE_DISABLED" == "false" ]]; then
                save_to_default_dir "$url" "$sub_content"
            fi

            # Handle output (print to stdout or save to specified file)
            if [[ "$OUTPUT" == "-" ]]; then
                # Output to stdout
                echo "$sub_content"
            else
                # Save to specified file (with compression if needed)
                if [[ "$COMPRESSION_ENABLED" == "true" ]]; then
                    # Compress the output file
                    local temp_file=$(mktemp)
                    echo "$sub_content" > "$temp_file"
                    compress_file "$temp_file" "$OUTPUT"
                    rm -f "$temp_file"
                    log "Compressed subtitles saved to: $OUTPUT"
                else
                    # Save uncompressed
                    echo "$sub_content" > "$OUTPUT"
                    log "Subtitles saved to: $OUTPUT"
                fi
            fi
            rm -rf "$tmpdir"
            return 0
        else
            # Failure: either non-zero exit code or error message in output
            log "youtube_transcript_api CLI failed for video: $video_id"
            if [[ -n "$api_output" ]]; then
                echo "$api_output" >&2  # Output error to stderr
            fi
            rm -rf "$tmpdir"
            return 1
        fi
    else
        log "youtube_transcript_api is not installed. Install it with: pip install youtube-transcript-api"
        echo "Error: Neither yt-dlp nor youtube_transcript_api could extract subtitles." >&2
        echo "Error: youtube_transcript_api is not installed. Install it with: pip install youtube-transcript-api" >&2
        rm -rf "$tmpdir"
        return 1
    fi
}

# -------------------------------
# Main processing loop
# -------------------------------
for item in "${ARGS[@]}"; do
    if [[ "$item" =~ ^https?:// ]]; then
        # URL case
        [[ "$SOURCE" == "embedded" ]] && { log "Skipping URL $item because source=embedded"; continue; }
        if ! get_subs_from_url "$item"; then
            # Error message is already handled within get_subs_from_url
            exit 1
        fi
        elif [[ -f "$item" ]]; then
        found_embedded=0
        if [[ "$SOURCE" == "embedded" || "$SOURCE" == "auto" ]]; then
            # Try to get URL for video file to use for saving with video ID
            url=""
            # Check if we can get a URL for the video file to extract video ID
            if [[ -x "$curdir/yt.links" ]]; then
                url=$("$curdir/yt.links" "$item" || true)
            fi

            if extract_embedded_subs "$item" "$url"; then
                found_embedded=1
            fi
        fi

        # Online fallback
        if [[ "$SOURCE" == "online" || ( "$SOURCE" == "auto" && "$found_embedded" -eq 0 ) ]]; then
            if [[ -x "$curdir/yt.links" ]]; then
                log "Trying yt.links for $item..."
                url=$("$curdir/yt.links" "$item" || true)
                if [[ -n "$url" ]]; then
                    if ! get_subs_from_url "$url"; then
                        # Error message is already handled within get_subs_from_url
                        exit 1
                    fi
                else
                    log "No URL found via yt.links for $item"
                fi
            else
                log "yt.links not found or not executable in $curdir."
            fi
        elif [[ "$found_embedded" -eq 1 && "$USE_CACHE" == "true" && "$CACHE_DISABLED" == "false" && -z "$url" ]]; then
            # If we found embedded subtitles and caching is enabled, but no URL is available
            # we can't save to the default directory since we don't have a video ID
            log "Embedded subtitles found but no URL available for caching functionality (video ID required for filename)"
        fi
    else
        log "Skipping invalid input: $item"
    fi
done