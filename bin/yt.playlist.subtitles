#!/usr/bin/env bash
# Download subtitles from a YouTube playlist
# Uses yt.playlist to get links and subtitle --save to download and save subtitles

set -euo pipefail

# Color and emoji constants
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Emoji constants
CHECKMARK="‚úÖ"
CROSS="‚ùå"
INFO="‚ÑπÔ∏è"
WARNING="‚ö†Ô∏è"
DOWNLOAD="üì•"
PLAYLIST="‚ñ∂Ô∏è"
SUCCESS="üéâ"
ERROR="üö®"

# Script path info
curfile=$(basename "$0")
curdir=$(realpath "$(dirname "$0")")

# Default values
VERBOSE=0
HELP=0
PARALLEL=1
PLAYLIST_URL=""
LANG="eng"
BROWSER=""
COOKIES=""
PROFILE=""
DEFAULT_PLAYLIST_URL="https://www.youtube.com/playlist?list=WL"

# Function to display help message
show_help() {
    cat << 'EOF'
Usage: yt.playlist.subtitles [OPTIONS] [PLAYLIST_URL]

Download subtitles from all videos in a YouTube playlist.
Subtitles are cached to $XDG_CONFIG_HOME/youtube-subtitles/VIDEOID.LANG.srt

If no PLAYLIST_URL is provided, defaults to Watch Later playlist (WL).

Options:
  -h, --help            Show this help message and exit
  -l, --lang LANG       Language code for subtitles (default: eng)
  -v, --verbose         Enable verbose output
  -j, --parallel NUM    Number of concurrent subtitle downloads (default: 1)
  --browser BROWSER     Specify browser for yt.playlist
  --cookies FILE        Path to cookies file for yt.playlist
  --profile NAME        Profile name for yt.playlist

Examples:
  yt.playlist.subtitles                        # Downloads from Watch Later playlist
  yt.playlist.subtitles --browser firefox      # Downloads from Watch Later using Firefox
  yt.playlist.subtitles https://www.youtube.com/playlist?list=PLat4GgaVK09caz8Q_9mElDVS-4nbRZtKU
  yt.playlist.subtitles -l es https://www.youtube.com/playlist?list=PLat4GgaVK09caz8Q_9mElDVS-4nbRZtKU

Requirements:
  - yt.playlist (for extracting playlist video links)
  - subtitle with --cache option (for downloading and caching subtitles)
  - yt-dlp (for downloading subtitles)
EOF
}

# Function to print colored messages
print_status() {
    local color="$1"
    local emoji="$2"
    local message="$3"
    echo -e "${color}${emoji}${NC} ${message}"
}

# Function to print error messages
print_error() {
    local message="$1"
    echo -e "${RED}${ERROR}${NC} ${message}" >&2
}

# Function to print verbose messages
print_verbose() {
    if [[ $VERBOSE -eq 1 ]]; then
        local message="$1"
        echo -e "${CYAN}${INFO}${NC} ${message}"
    fi
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            HELP=1
            shift
            ;;
        -l|--lang)
            LANG="$2"
            shift 2
            ;;
        --lang=*)
            LANG="${1#*=}"
            shift
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -j|--parallel)
            PARALLEL="$2"
            shift 2
            ;;
        --parallel=*)
            PARALLEL="${1#*=}"
            shift
            ;;
        --browser)
            BROWSER="$2"
            shift 2
            ;;
        --cookies)
            COOKIES="$2"
            shift 2
            ;;
        --profile)
            PROFILE="$2"
            shift 2
            ;;
        http*)
            PLAYLIST_URL="$1"
            shift
            ;;
        -*)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            PLAYLIST_URL="$1"
            shift
            ;;
    esac
done

# Show help if requested
if [[ $HELP -eq 1 ]]; then
    show_help
    exit 0
fi

# Validate PARALLEL parameter
if ! [[ "$PARALLEL" =~ ^[1-9][0-9]*$ ]]; then
    print_error "Parallel value must be a positive integer"
    exit 1
fi

# Use default playlist URL if none provided
if [[ -z "$PLAYLIST_URL" ]]; then
    PLAYLIST_URL="$DEFAULT_PLAYLIST_URL"
fi

# Check dependencies
if [[ ! -x "$curdir/yt.playlist" ]]; then
    print_error "yt.playlist script not found in $curdir"
    exit 1
fi

if [[ ! -x "$curdir/subtitle" ]]; then
    print_error "subtitle script not found in $curdir"
    exit 1
fi

# Prepare arguments for yt.playlist
yt_playlist_args=("$PLAYLIST_URL")
if [[ -n "$BROWSER" ]]; then
    yt_playlist_args+=(--browser "$BROWSER")
fi
if [[ -n "$COOKIES" ]]; then
    yt_playlist_args+=(--cookies "$COOKIES")
fi
if [[ -n "$PROFILE" ]]; then
    yt_playlist_args+=(--profile "$PROFILE")
fi

# Extract video links from the playlist
print_verbose "Extracting videos from playlist: $PLAYLIST_URL"
print_verbose "yt.playlist arguments: ${yt_playlist_args[*]}"

# Use a safer approach to avoid xargs issues with quotes in titles
if [[ -n "$COOKIES" ]]; then
    video_links=$(yt-dlp --quiet --no-warnings --flat-playlist --cookies "$COOKIES" --print "%(webpage_url)s  |  %(title)s" "$PLAYLIST_URL" 2>/dev/null)
elif [[ -n "$BROWSER" ]] && [[ -n "$PROFILE" ]]; then
    video_links=$(yt-dlp --quiet --no-warnings --flat-playlist --cookies-from-browser "$BROWSER:$PROFILE" --print "%(webpage_url)s  |  %(title)s" "$PLAYLIST_URL" 2>/dev/null)
elif [[ -n "$BROWSER" ]]; then
    video_links=$(yt-dlp --quiet --no-warnings --flat-playlist --cookies-from-browser "$BROWSER" --print "%(webpage_url)s  |  %(title)s" "$PLAYLIST_URL" 2>/dev/null)
else
    video_links=$("$curdir/yt.playlist" "${yt_playlist_args[@]}" 2>/dev/null)
fi

if [[ -z "$video_links" ]]; then
    print_error "No videos found in playlist"
    exit 1
fi

# Count total videos
total_videos=$(echo "$video_links" | grep -v '^$' | wc -l)
processed_count=0
success_count=0
failure_count=0

print_status "$BLUE" "$PLAYLIST" "Processing $total_videos videos from playlist..."

# Process video links with parallelism
processed_count=0
success_count=0
failure_count=0
video_data_file=$(mktemp)
result_file=$(mktemp)
# Create a lock directory for job counting
lock_dir=$(mktemp -d)
trap "rm -rf '$video_data_file' '$result_file' '$lock_dir'" EXIT

# Store video data in file for parallel processing
while IFS= read -r line; do
    # Skip empty lines
    [[ -z "$line" ]] && continue

    # Extract the URL from the line (format: "URL  |  title")
    # Use parameter expansion to trim leading/trailing whitespace instead of xargs
    raw_url=$(echo "$line" | cut -d'|' -f1)
    raw_title=$(echo "$line" | cut -d'|' -f2-)

    # Trim leading and trailing whitespace without using xargs
    video_url="${raw_url#"${raw_url%%[![:space:]]*}"}"   # Remove leading whitespace
    video_url="${video_url%"${video_url##*[![:space:]]}"}"  # Remove trailing whitespace
    video_title="${raw_title#"${raw_title%%[![:space:]]*}"}"   # Remove leading whitespace
    video_title="${video_title%"${video_title##*[![:space:]]}"}"  # Remove trailing whitespace

    processed_count=$((processed_count + 1))
    echo "$video_url|$video_title|$processed_count" >> "$video_data_file"

    print_verbose "Queued ($processed_count/$total_videos): $video_url"
    if [[ -n "$video_title" ]]; then
        print_verbose "Title: $video_title"
    fi
done <<< "$video_links"

# Process videos in parallel with job control
total_to_process=$processed_count

# Function to process a single video
process_video() {
    local video_url="$1"
    local video_title="$2"
    local processed_num="$3"
    local total_count="$4"

    # Download subtitle for this video using --cache option
    if output=$("$curdir/subtitle" --cache -l "$LANG" -f srt "$video_url" 2>&1); then
        echo "SUCCESS|$processed_num|$video_title" >> "$result_file"
        # Print success message immediately with direct color codes since running in subshell
        echo -e "\033[0;32m‚úÖ\033[0m ($processed_num/$total_count) Successfully downloaded subtitle for: $video_title"
        if [[ $VERBOSE -eq 1 ]]; then
            echo "OUTPUT|$output" >> "$result_file"
        fi
    else
        echo "FAILURE|$processed_num|$video_title|$(echo "$output" | head -n 1)" >> "$result_file"
        # Print failure message immediately with direct color codes since running in subshell
        echo -e "\033[0;31m‚ùå\033[0m ($processed_num/$total_count) Failed to download subtitle for: $video_title" >&2
        if [[ $VERBOSE -eq 1 ]]; then
            echo "$output" >&2
        else
            echo -e "\033[0;31m$(echo "$output" | head -n 1)\033[0m" >&2
        fi
    fi
}

# Process each video, controlling parallelism
while IFS='|' read -r video_url video_title processed_num; do
    # Process subtitle download in background - pass all needed variables
    process_video "$video_url" "$video_title" "$processed_num" "$total_to_process" &

    # Wait when we have too many background jobs running
    while (( $(jobs -r | wc -l) >= PARALLEL )); do
        wait -n  # Wait for any one job to finish
    done
done < "$video_data_file"

# Wait for all remaining jobs to complete
wait

# Process results and count successes/failures
while IFS='|' read -r status num title extra; do
    case "$status" in
        "SUCCESS")
            ((success_count++))
            print_status "$GREEN" "$CHECKMARK" "($num/$total_to_process) Successfully downloaded subtitle for: $title"
            ;;
        "FAILURE")
            ((failure_count++))
            print_status "$RED" "$CROSS" "($num/$total_to_process) Failed to download subtitle for: $title"
            if [[ $VERBOSE -eq 1 ]]; then
                echo "$extra" >&2
            else
                # Show summary of error in non-verbose mode
                echo -e "${RED}$extra${NC}" >&2
            fi
            ;;
        "OUTPUT")
            echo "$extra"
            ;;
    esac
done < "$result_file"

print_status "$PURPLE" "$SUCCESS" "Finished processing playlist: $success_count successful, $failure_count failed"