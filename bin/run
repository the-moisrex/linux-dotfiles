#!/bin/bash

RED="\033[0;31m"
GRAY="\033[0;37m"
NC="\033[0m" # No Color


gitroot=".git";
until [ "$(realpath "$gitroot" 2>/dev/null)" = "/.git" -o \
      "$(realpath "$gitroot" 2>/dev/null)" = "/" -o \
      -d "$gitroot" \
    ]; do
gitroot="../${gitroot}";
done;

proj_dir="$(realpath "$gitroot/.." 2>/dev/null)";
build_dir="$proj_dir/build";


function print_cmake_targets {
    current_version=$(cmake --version | grep "cmake version" | cut -d" " -f3)
    version="3.27"
    if [[ $(echo -e "$version\n$current_version" | sort --version-sort -r | head -n1) == "$current_version" ]]; then
        # newer versions of cmake
        cmake --build "$build_dir" --target help | cut -d" " -f2 | tail -n +2
    else
        # older versions of cmake
        cmake --build "$build_dir" --target help | grep -v phony | cut -d: -f1 | tail -n +2
    fi
}

function run {
  scan_build="";
  debug_cmd=""
  if [ "$1" == "analyze" ]; then
      scan_build="scan-build"
      shift;
  elif [ "$1" == "lldb" ]; then
      debug_cmd="lldb";
      shift;
  elif [ "$1" == "gdb" ]; then
      debug_cmd="gdb";
      shift;
  fi

  old_dir=$(pwd);
  execfile="$@";

  if [ -d "$gitroot" -a -d "$proj_dir" -a -d "$build_dir" ]; then
    if [ -f "$build_dir/CMakeCache.txt" ]; then
      build_cmd="cmake --build '$build_dir' --target $execfile";
    elif [ -f "$build_dir/build.ninja" ]; then
      build_cmd="ninja -C '$build_dir' -v $execfile";
    elif [ -f "Makefile" ]; then
      build_cmd="make -C '$build_dir' $execfile";
    else
      echo -e "${RED}Wrong build directory.${NC}";
      return;
    fi;
    clear;
    echo -e "${GRAY}Project root:${NC}    $proj_dir"
    echo -e "${GRAY}Build Directory:${NC} $build_dir"
    echo -e "${GRAY}Build command:${NC}   $scan_build $build_cmd"
    echo -e "${GRAY}Exec command:${NC}    $scan_build $debug_cmd $execfile"
    if eval "unbuffer $scan_build $build_cmd"; then
      timeout 1s notify-send -t 800 -i utilities-terminal -a "Compiler" "Compiled Seccessfully.";
      if [ -f "$build_dir/$execfile" ]; then
        execfile="$build_dir/$execfile";
      fi
      if eval "$scan_build $debug_cmd $execfile"; then
        timeout 1s notify-send -t 1000 -i utilities-terminal -a "Compiler" "Tests Passed";
      else
        timeout 1s notify-send -t 1000 -i utilities-terminal -a "Compiler" "Tests Failed";
      fi;
    else
      timeout 1s notify-send -t 800 -i utilities-terminal -a "Compiler" "Compilation Failed.";
    fi;
  else
    echo -e "${RED}Project Root not found.${NC}"
  fi;
}


function keep-running {
  git -C "$proj_dir" ls-files -cm | entr -ardc $0 $@
}


exec_name=$(realpath "$0");
function print_help {
    echo "$exec_name help"
    echo "           [target]                     # the target to compile/run"
    echo "           keep [target]                # keep running the target"
    echo "           analyze/scan-build [target]  # "
    echo "           lldb/gdb [target]            # run lldb/gdb on the target"
    echo "           less [command]               # pipe 'command' to 'less -r'"
}


# Make a copy
args=("$@")

arg_pos=-1
for arg in "${args[@]}"; do
    arg_pos=$(($arg_pos + 1))
    case $arg in
        -r|less|-less|--less|-l|l)
            # Remove the string from the array by position
            unset "args[$arg_pos]"

            $0 ${args[@]} | less -r;
            exit $?
            ;;
        help)
            print_help;
            exit 0;
            ;;
        keep)
            # Remove the string from the array by position
            unset "args[$arg_pos]"
            keep-running "${args[@]}";
            exit $?
            ;;
    esac
done


case "$1" in
    analyze|scan-build)
        shift;
        run analyze $@;
        ;;
    lldb)
        shift;
        run lldb $@;
        ;;
    gdb)
        shift;
        run gdb $@;
        ;;
    print-targets)
        shift;
        print_cmake_targets;
        exit;
        ;;
    *)
        run $@;
        ;;
esac


