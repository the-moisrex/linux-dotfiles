#!/bin/bash

# Function to display help
show_help() {
    cat << EOF
Usage: $0 [ENGINE_SHORTCUTS...] <search query>

Generate search URLs for multiple search engines.

Engine Shortcuts:
  g, google       Google Search
  b, bing         Bing Search
  d, ddg          DuckDuckGo
  s, start        Startpage
  p, per          Perplexity AI
  c, chat, gpt    ChatGPT
  y, yahoo        Yahoo Search
  br, brave       Brave Search
  q, qwant        Qwant
  e, ecosia       Ecosia
  w, wolfram      WolframAlpha
  ya, yandex      Yandex
  bd, baidu       Baidu
  sw, swisscows   Swisscows
  m, mojeek       Mojeek
  sx, searxng     SearXNG
  all             All search engines

Categories:
  ai              AI category (Perplexity, ChatGPT)
  news            News category (Google, Bing, Yahoo, Yandex)
  tech            Tech category (Google, TechCrunch, Ars Technica)
  hacker-news, hn Hacker News category (Hacker News, Reddit, TechCrunch, Ars Technica)
  academic        Academic category (Google Scholar, WolframAlpha)
  privacy         Privacy category (DuckDuckGo, Startpage, Brave, Ecosia, SearXNG, Mojeek)
  social          Social category (Reddit, Twitter, Facebook)
  code            Code category (GitHub, Stack Overflow)

Examples:
  $0 g "quantum physics"           # Search only Google
  $0 g per "machine learning"      # Search Google and Perplexity
  $0 ai "machine learning"         # Search AI category (Perplexity and ChatGPT)
  $0 news "election results"       # Search news category
  $0 all "black holes"             # Search all engines
  $0 "simple query"                # Search basic engines (Google, Bing, DuckDuckGo, Startpage, Perplexity)
EOF
}

# Check if no arguments were provided
if [ $# -eq 0 ]; then
    show_help
    exit 1
fi

# Check for help option
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    show_help
    exit 0
fi

# Define engine mappings
declare -A engine_urls=(
    ["google"]="https://www.google.com/search?q="
    ["bing"]="https://www.bing.com/search?q="
    ["duckduckgo"]="https://duckduckgo.com/?q="
    ["startpage"]="https://www.startpage.com/sp/search?query="
    ["perplexity"]="https://www.perplexity.ai/search?q="
    ["yahoo"]="https://search.yahoo.com/search?p="
    ["brave"]="https://search.brave.com/search?q="
    ["qwant"]="https://www.qwant.com/?q="
    ["ecosia"]="https://www.ecosia.org/search?q="
    ["wolframalpha"]="https://www.wolframalpha.com/input/?i="
    ["yandex"]="https://yandex.com/search/?text="
    ["baidu"]="https://www.baidu.com/s?wd="
    ["chatgpt"]="https://chatgpt.com/?q="
    ["swisscows"]="https://swisscows.com/en/web?query="
    ["mojeek"]="https://www.mojeek.com/search?q="
    ["searxng"]="http://localhost:8080/search?q="
    ["hackernews"]="https://hn.algolia.com/?query="
    ["reddit"]="https://www.reddit.com/search/?q="
    ["techcrunch"]="https://techcrunch.com/search/?s="
    ["arstechnica"]="https://arstechnica.com/search/"
    ["scholar"]="https://scholar.google.com/scholar?q="
    ["twitter"]="https://twitter.com/search?q="
    ["facebook"]="https://www.facebook.com/search/top/?q="
    ["github"]="https://github.com/search?q="
    ["stackoverflow"]="https://stackoverflow.com/search?q="
)

# Define category mappings
declare -A categories=(
    ["ai"]="perplexity chatgpt"
    ["news"]="google bing yahoo yandex"
    ["tech"]="google techcrunch arstechnica"
    ["hacker-news"]="hackernews reddit techcrunch arstechnica"
    ["academic"]="google scholar wolframalpha"
    ["privacy"]="duckduckgo startpage brave ecosia searxng mojeek"
    ["social"]="reddit twitter facebook"
    ["code"]="github stackoverflow"
)

# Define shortcut mappings
declare -A shortcuts=(
    ["g"]="google"
    ["b"]="bing"
    ["d"]="duckduckgo"
    ["ddg"]="duckduckgo"
    ["s"]="startpage"
    ["c"]="chatgpt"
    ["gpt"]="chatgpt"
    ["chat"]="chatgpt"
    ["ai"]="ai"
    ["hn"]="hackernews"
    ["start"]="startpage"
    ["p"]="perplexity"
    ["per"]="perplexity"
    ["y"]="yahoo"
    ["yahoo"]="yahoo"
    ["br"]="brave"
    ["brave"]="brave"
    ["q"]="qwant"
    ["qwant"]="qwant"
    ["e"]="ecosia"
    ["ecosia"]="ecosia"
    ["w"]="wolframalpha"
    ["wolfram"]="wolframalpha"
    ["wa"]="wolframalpha"
    ["ya"]="yandex"
    ["yandex"]="yandex"
    ["bd"]="baidu"
    ["baidu"]="baidu"
    ["sw"]="swisscows"
    ["m"]="mojeek"
    ["sx"]="searxng"
    ["all"]="all"
    ["news"]="news"
    ["tech"]="tech"
    ["hacker-news"]="hacker-news"
    ["hacker"]="hacker-news"
    ["hn"]="hacker-news"
    ["academic"]="academic"
    ["privacy"]="privacy"
    ["social"]="social"
    ["code"]="code"
)

# Function to check if searXNG is running
is_searxng_running() {
    if command -v curl >/dev/null 2>&1; then
        # Check if searXNG is running on localhost:8080
        curl -s --max-time 1 http://localhost:8080/ >/dev/null 2>&1
        return $?
    elif command -v wget >/dev/null 2>&1; then
        # Alternative check using wget
        wget --timeout=1 -q --spider http://localhost:8080/ 2>/dev/null
        return $?
    else
        # If no tool available, assume searXNG is not running
        return 1
    fi
}

# Default engines (used when no specific engines are requested)
default_engines=("google" "bing" "duckduckgo" "startpage" "swisscows" "mojeek")
# Add searXNG to default engines only if it's running
if is_searxng_running; then
    default_engines+=("searxng")
fi

# URL-encode function using python3 for better encoding
encode_query() {
    python3 -c "import urllib.parse, sys; print(urllib.parse.quote_plus(sys.argv[1]))" "$1"
}

# Parse arguments to extract engines and query
engines=()
query_parts=()
all_engines=false
processing_engines=true

for arg in "$@"; do
    if [ "$processing_engines" = true ]; then
        if [ -n "${shortcuts[$arg]}" ]; then
            shortcut_target="${shortcuts[$arg]}"
            if [ "$shortcut_target" = "all" ]; then
                all_engines=true
            elif [ -n "${categories[$shortcut_target]}" ]; then
                # Expand category to its constituent engines
                category_engines=(${categories[$shortcut_target]})
                for cat_engine in "${category_engines[@]}"; do
                    if [[ ! " ${engines[@]} " =~ " ${cat_engine} " ]]; then  # Avoid duplicates
                        engines+=("$cat_engine")
                    fi
                done
            else
                # Add the individual engine if not already present
                if [[ ! " ${engines[@]} " =~ " ${shortcut_target} " ]]; then
                    engines+=("$shortcut_target")
                fi
            fi
        else
            # First non-engine argument, treat as start of query
            processing_engines=false
            query_parts+=("$arg")
        fi
    else
        query_parts+=("$arg")
    fi
done

# Combine query parts
query="${query_parts[*]}"

# Check if query is empty and try to read from stdin
if [ -z "$query" ]; then
    # Check if there is piped input by testing if stdin is not a terminal
    if [ ! -t 0 ]; then
        # Read from stdin if available
        query=$(cat)
        query=$(echo "$query" | xargs)  # Trim leading/trailing whitespace
    fi
fi

# Check if query is still empty
if [ -z "$query" ]; then
    echo "Error: No search query provided"
    show_help
    exit 1
fi

# Set engines based on input
if [ "$all_engines" = true ]; then
    engines=("${!engine_urls[@]}")
    elif [ ${#engines[@]} -eq 0 ]; then
    engines=("${default_engines[@]}")
fi

# URL-encode the query
encoded_query=$(encode_query "$query")

# Generate and print URLs
# echo "Search URLs for: \"$query\""
# echo "=========================================="

for engine in "${engines[@]}"; do
    if [ -n "${engine_urls[$engine]}" ]; then
        # echo "[$engine] ${engine_urls[$engine]}$encoded_query"
        echo "${engine_urls[$engine]}$encoded_query"
    fi
done
