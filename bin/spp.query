#!/usr/bin/env python3
import subprocess
import sys
import os
import argparse
import json

parser = argparse.ArgumentParser(description="Find C++ symbol declarations/definitions using clang-query")
parser.add_argument("symbol", help="Symbol name to search for")
parser.add_argument("--verbose", action="store_true", help="Enable verbose output")
parser.add_argument("--traverse-all", action="store_true", help="Use AsIs traversal instead of IgnoreUnlessSpelledInSource")
args = parser.parse_args()

SYMBOL = args.symbol
VERBOSE = args.verbose
TRAVERSE_ALL = args.traverse_all

# -----------------------------
# Step 0: Find compile_commands.json
# -----------------------------
cc_path = None
for root, dirs, files in os.walk("."):
    if "compile_commands.json" in files:
        cc_path = os.path.join(root, "compile_commands.json")
        break

if not cc_path:
    print("No compile_commands.json found.")
    sys.exit(1)

build_dir = os.path.dirname(cc_path)
if VERBOSE:
    print(f"Found compile_commands.json in: {build_dir}")

# -----------------------------
# Step 1: Find header files containing the symbol
# -----------------------------
try:
    result = subprocess.run(
        ["git", "grep", "-l", SYMBOL, "--", "*.h", "*.hh", "*.hpp"],
        capture_output=True, text=True, check=True
    )
    headers = sorted(set(result.stdout.strip().splitlines()))
except subprocess.CalledProcessError:
    headers = []

if not headers:
    if VERBOSE:
        print(f"No header files found containing '{SYMBOL}'")
    sys.exit(0)

if VERBOSE:
    print(f"Found {len(headers)} header file(s) containing '{SYMBOL}':")
    for h in headers:
        print(f"  {h}")

# -----------------------------
# Step 2: Load translation units from compile_commands.json
# -----------------------------
with open(cc_path) as f:
    compile_db = json.load(f)

all_tus = [entry["file"] for entry in compile_db if entry["file"].endswith((".cpp", ".cxx", ".cc"))]

# -----------------------------
# Step 3: Find TUs including the headers
# -----------------------------
translation_units = set()
for tu in all_tus:
    for header in headers:
        try:
            subprocess.run(["grep", "-q", header, tu], check=True,
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            translation_units.add(tu)
            break
        except subprocess.CalledProcessError:
            continue

translation_units = sorted(translation_units)

if not translation_units:
    if VERBOSE:
        print(f"No translation units including the header(s) found")
    sys.exit(0)

if VERBOSE:
    print(f"Found {len(translation_units)} translation unit(s) referencing the header(s):")
    for tu in translation_units:
        print(f"  {tu}")

# -----------------------------
# Step 4: Build clang-query command
# -----------------------------
MATCHER = f'namedDecl(hasName("{SYMBOL}")).bind("symbolDecl")'
COMPILER_FLAGS = ["-std=c++26", "-ferror-limit=0", "-Wno-everything"]
clang_query_cmd = ["clang-query"] + translation_units + ["-p", build_dir, "--"] + COMPILER_FLAGS

if VERBOSE:
    print("Running clang-query command:")
    print(" ".join(clang_query_cmd))

# -----------------------------
# Step 5: Run clang-query with print output
# -----------------------------
traversal_mode = "AsIs" if TRAVERSE_ALL else "IgnoreUnlessSpelledInSource"

commands = f"""
set traversal {traversal_mode}
set output print
match {MATCHER}
quit
"""

process = subprocess.Popen(clang_query_cmd,
                           stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           text=True)
stdout, stderr = process.communicate(input=commands)

if VERBOSE and stderr.strip():
    print("clang-query warnings/errors (ignored):")
    print(stderr.strip())

# -----------------------------
# Step 6: Remove the final "N matches." line precisely
# -----------------------------
stdout_lines = stdout.splitlines()
stdout_lines = [line for line in stdout_lines if not line.strip().endswith("matches.")]
stdout = "\n".join(stdout_lines)

# -----------------------------
# Step 7: Parse matches and deduplicate
# -----------------------------
matches = stdout.split("Match #")[1:]  # Split into individual match blocks
unique_symbols = set()
cleaned_matches = []

for match in matches:
    lines = []
    in_print_block = False
    for line in match.splitlines():
        line = line.rstrip()
        if line.startswith('Binding for "symbolDecl":'):
            in_print_block = True
            continue
        if line.startswith("Binding for") and in_print_block:
            break
        if in_print_block:
            lines.append(line)
    block = "\n".join(lines).strip()
    if block and block not in unique_symbols:
        unique_symbols.add(block)
        cleaned_matches.append(block)

# -----------------------------
# Step 8: Output
# -----------------------------
print("\n\n".join(cleaned_matches))

