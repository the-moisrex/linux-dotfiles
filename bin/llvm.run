#!/usr/bin/env python3
"""
Python replacement for `llvm.run` using LLVM plugin subprocess with:
- .clang/.clangd flags support
- Header TU handling
"""

import argparse
import subprocess
from pathlib import Path
import shlex
import sys

# Global array of essential clang flags to use by default
ESSENTIAL_CLANG_FLAGS = [
    # Warning suppression flags
    "-Wno-assume",  # For the assumption warning in webpp
    "-Wno-character-conversion",  # For the character conversion warning
    "-Wno-ignored-attributes",  # To suppress ignored attribute warnings
    "-Wno-deprecated-declarations",  # To suppress deprecated declarations warnings
    "-Wno-invalid-source-encoding",  # Suppress invalid source encoding warnings
    "-Wno-undefined-internal",  # Suppress undefined internal warnings
    "-Wno-gnu-anonymous-struct",  # Suppress gnu anonymous struct warnings
    "-Wno-nested-anon-types",  # Suppress nested anonymous types warnings
    "-w"  # Suppress all warnings to reduce output noise
]

# Global list of flags to exclude from clang compilation
EXCLUDE_FLAGS = [
    "--header-insertion=",  # Note: including the equals sign to match full flag patterns like --header-insertion=never
    "--limit-references",
    "--limit-results",
    "-W",
    "-Wall",
    "-Wextra",
    "-Wpedantic",
    "-Werror=implicit-function-declaration",
    "-Wshadow",
    "-Wuninitialized",
    "-Wunused-label",
    "-Wunused-lambda-capture",
]

def get_git_root():
    current = Path(".").resolve()
    while not (current / ".git").exists() and current.parent != current:
        current = current.parent
    return current


# ----------------------------
# Read valid clang flags from .clang/.clangd
# ----------------------------
def read_clang_flags(git_root, verbose=False):
    flags = []

    for file_name in [".clang", ".clangd"]:
        path = git_root / file_name
        if path.exists():
            if verbose:
                print(f"[verbose] Reading clang flags from {path}")
            try:
                text = path.read_text()
                if file_name == ".clangd":
                    # Parse .clangd YAML-like format - look for flags in Add: array
                    in_add_line = False
                    for line in text.splitlines():
                        line = line.rstrip()
                        if line.strip().startswith("Add:"):
                            # Extract flags from the Add: line which should be in the format: Add: [-flag1, -flag2, ...]
                            # The format may be: Add: [-std=c++23, --limit-references, ...]
                            content = line.split("Add:", 1)[1].strip()
                            # Remove the opening bracket and closing bracket
                            content = content.strip('[]')
                            # Split by commas and process each flag
                            flag_items = [item.strip().strip('"\'') for item in content.split(',')]
                            for flag_item in flag_items:
                                flag_item = flag_item.strip()
                                if flag_item.startswith('-'):
                                    # Skip flags that should be excluded
                                    should_exclude = False
                                    for exclude_flag in EXCLUDE_FLAGS:
                                        if exclude_flag.endswith('='):
                                            # For flags with an equals sign, check if the flag starts with the base part
                                            base_flag = exclude_flag.rstrip('=')
                                            if flag_item.startswith(base_flag + '=') or flag_item == base_flag:
                                                should_exclude = True
                                                break
                                        else:
                                            # For flags without equals, use startswith
                                            if flag_item.startswith(exclude_flag):
                                                should_exclude = True
                                                break
                                    if not should_exclude:
                                        flags.append(flag_item)
                        elif line.strip().startswith("CompilationDatabase:"):
                            # Get compilation database path
                            comp_db_path = line.split(":", 1)[1].strip()
                            # Add compilation database flags if the directory exists
                            db_path = git_root / comp_db_path
                            if db_path.exists() and db_path.is_dir():
                                flags.append(f"-p={db_path}")
                else:  # .clang file - one flag per line
                    for line in text.splitlines():
                        line = line.strip()
                        if not line or line.startswith("#"):
                            continue
                        # Split by spaces
                        for token in shlex.split(line):
                            # Split comma-separated flags
                            subtokens = [t.strip() for t in token.split(",") if t.strip()]
                            for sub in subtokens:
                                # Skip flags that should be excluded
                                should_exclude = False
                                for exclude_flag in EXCLUDE_FLAGS:
                                    if exclude_flag.endswith('='):
                                        # For flags with an equals sign, check if the flag starts with the base part
                                        base_flag = exclude_flag.rstrip('=')
                                        if sub.startswith(base_flag + '=') or sub == base_flag:
                                            should_exclude = True
                                            break
                                    else:
                                        # For flags without equals, use startswith
                                        if sub.startswith(exclude_flag):
                                            should_exclude = True
                                            break
                                if not should_exclude:
                                    flags.append(sub)
            except Exception as e:
                if verbose:
                    print(f"[verbose] Failed reading {path}: {e}")
    return flags

# ----------------------------
# Find files using git grep
# ----------------------------
def git_grep_files(plugin_arg, verbose=False):
    cmd = ["git", "grep", "-l", plugin_arg, "--", "*.cpp", "*.cxx", "*.ixx", "*.cc", "*.h", "*.hpp"]
    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)
    files = result.stdout.strip().splitlines()
    if verbose:
        print(f"[verbose] Found files: {files}")
    return files

# ----------------------------
# Build the LLVM plugin shared library if it doesn't exist
# ----------------------------
def build_llvm_plugin(plugin_name, verbose=False):
    # The script is in bin directory, so llvm directory should be at ../llvm
    script_dir = Path(__file__).resolve().parent
    llvm_dir = script_dir.parent / "llvm"
    
    if not llvm_dir.exists():
        raise FileNotFoundError(f"LLVM directory not found at {llvm_dir}")
    
    # Look through source files to find one that registers the plugin name
    source_file = llvm_dir / (plugin_name + ".cpp")
    if not source_file.exists():
        # Look for source files that might contain the plugin implementation
        source_files = []
        
        for ext in ["*.cpp", "*.cxx", "*.cc"]:
            for file_path in llvm_dir.glob(ext):
                if file_path.is_file():
                    source_files.append(file_path)
        
        if not source_files:
            raise FileNotFoundError(f"No source files found in llvm directory")
    
        raise FileNotFoundError(f"Plugin '{plugin_name}' not found in any source file in llvm directory. Available source files: {[f.name for f in source_files]}")
    
    lib_name = f"lib{plugin_name}.so"
    lib_path = llvm_dir / lib_name
    
    if not lib_path.exists():
        if verbose:
            print(f"[verbose] Building {lib_name} from {source_file}")
        # Try to find clang installation location and get proper include paths
        try:
            # Find clang++ and use it to get system include paths
            result = sp.run(["clang++", "-v", "-E", "-x", "c++", "/dev/null", "-o", "/dev/null"], 
                           capture_output=True, text=True)
            if result.returncode == 0 and "#include <...> search starts here:" in result.stderr:
                lines = result.stderr.split('\n')
                in_includes = False
                include_flags = []
                for line in lines:
                    if "#include <...> search starts here:" in line:
                        in_includes = True
                        continue
                    elif "End of search list." in line:
                        in_includes = False
                        break
                    elif in_includes:
                        path = line.strip()
                        if path:
                            include_flags.append(f"-I{path}")
            else:
                include_flags = []
        except:
            include_flags = []
        
        build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC"]
        build_cmd.extend(include_flags)  # Add include flags from clang
        build_cmd.extend(["-lclang-cpp", str(source_file), "-o", str(lib_path)])
        
        result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
        if result.returncode != 0:
            if verbose:
                print(f"[verbose] First build attempt failed: {result.stderr}")
            # If the build fails, try finding clang installation using pkg-config or other methods
            clang_include_flags = []
            try:
                # Try to get flags from pkg-config
                pkg_result = sp.run(["pkg-config", "--cflags", "libclang"], capture_output=True, text=True)
                if pkg_result.returncode == 0:
                    pkg_flags = pkg_result.stdout.strip().split()
                    clang_include_flags.extend(pkg_flags)
            except:
                pass
            
            # If pkg-config didn't work, try common locations
            if not clang_include_flags:
                common_paths = [
                    "/usr/lib/clang/*/include",
                    "/usr/include/clang/*/include", 
                    "/usr/local/include/clang/*/include",
                    "/opt/homebrew/include/clang/*/include",
                    "/usr/include",
                ]
                
                import glob
                for pattern in common_paths:
                    matches = glob.glob(pattern)
                    if matches:
                        clang_include_flags.append(f"-I{matches[-1]}")  # Use the latest version
                        break
            
            build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC"]
            build_cmd.extend(clang_include_flags)
            build_cmd.extend(["-lclang-cpp", str(source_file), "-o", str(lib_path)])
            
            result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
            if result.returncode != 0:
                if verbose:
                    print(f"[verbose] Second build attempt failed: {result.stderr}")
                # Final fallback: just try the basic build
                build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC", str(source_file), "-o", str(lib_path)]
                result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
                if result.returncode != 0:
                    raise RuntimeError(f"Failed to build plugin: {result.stderr}")
    
    return lib_path

# ----------------------------
# Process files using LLVM plugin
# ----------------------------
def extract_with_plugin(plugin_name, plugin_args, files, extra_flags, git_root, verbose=False):
    try:
        # Build the plugin if needed
        lib_path = build_llvm_plugin(plugin_name, verbose=verbose)
    except Exception as e:
        print(f"Error: Could not build plugin '{plugin_name}': {e}", file=sys.stderr)
        sys.exit(1)
    
    # Check that the plugin file actually exists and is accessible
    if not lib_path.exists():
        print(f"Error: Plugin library {lib_path} was not created successfully", file=sys.stderr)
        sys.exit(1)
    
    # The script is in bin directory, so llvm directory should be at ../llvm
    script_dir = Path(__file__).resolve().parent
    llvm_dir = script_dir.parent / "llvm"
    
    if not llvm_dir.exists():
        raise FileNotFoundError(f"LLVM directory not found at {llvm_dir}")
    
    processed_files = []
    
    for file in files:
        path = Path(file)
        
        # The file path could be relative to the project root or llvm dir
        # First, check if it exists as-is (relative to current directory)
        if path.exists():
            abs_file_path = path.resolve()
        # Then check if it exists relative to the llvm directory
        elif (llvm_dir / path).exists():
            abs_file_path = (llvm_dir / path).resolve()
        # Then check if it exists relative to git root
        elif (git_root / path).exists():
            abs_file_path = (git_root / path).resolve()
        else:
            # If it doesn't exist in either location, we'll still add it and let clang handle the error
            abs_file_path = path.resolve() if path.is_absolute() else (Path.cwd() / path).resolve()
        
        processed_files.append(abs_file_path)

    # clang command with LLVM plugin
    lib_name = f"lib{plugin_name}.so"
    
    # Essential flags
    std_flags = ESSENTIAL_CLANG_FLAGS.copy()
    
    # Add extra flags (from .clang/.clangd) but remove duplicates to prevent issues like "-std=c++23 -std=c++23" 
    # Placing these early to ensure language settings like -std=c++23 are applied before file processing
    unique_extra_flags = []
    seen_flags = set()
    seen_std_flags = False  # Track if we've already seen a -std flag to avoid duplicates
    i = 0
    while i < len(extra_flags):
        flag = extra_flags[i]
        if flag in ['-std', '-I', '-isystem', '-include', '-D', '-L', '-l']:
            # This is a flag that takes an argument, so combine with next value
            if i + 1 < len(extra_flags):
                combined_flag = f"{flag} {extra_flags[i+1]}"
                
                # Special handling for -std flags to avoid duplicates
                if flag == '-std':
                    if seen_std_flags:
                        # Skip this -std flag since we've already seen one
                        i += 2
                        continue
                    else:
                        seen_std_flags = True
                elif flag.startswith('-std='):
                    if seen_std_flags:
                        # Skip this -std flag since we've already seen one
                        i += 2
                        continue
                    else:
                        seen_std_flags = True
                        
                if combined_flag not in seen_flags:
                    unique_extra_flags.extend([flag, extra_flags[i+1]])
                    seen_flags.add(combined_flag)
                i += 2
            else:
                if flag not in seen_flags:
                    unique_extra_flags.append(flag)
                    seen_flags.add(flag)
                i += 1
        elif flag.startswith(('-std=', '-I', '-isystem', '-include', '-D', '-L', '-l')):
            # This is a flag=value format (like -std=c++23, -I./, etc.)
            
            # Special handling for -std= flags to avoid duplicates
            if flag.startswith('-std='):
                if seen_std_flags:
                    # Skip this -std flag since we've already seen one
                    i += 1
                    continue
                else:
                    seen_std_flags = True
            
            if flag not in seen_flags:
                unique_extra_flags.append(flag)
                seen_flags.add(flag)
        else:
            # Regular flag
            if flag not in seen_flags:
                unique_extra_flags.append(flag)
                seen_flags.add(flag)
        i += 1
    
    cmd = ["clang++", "-fsyntax-only", "-x", "c++"] + std_flags + unique_extra_flags
    
    # Add plugin loading and plugin arguments via -Xclang
    plugin_load = ["-Xclang", "-load", "-Xclang", str(lib_path)]
    plugin_load.extend(["-Xclang", "-add-plugin", "-Xclang", plugin_name])

    # Add all plugin arguments directly
    for arg in plugin_args:
        plugin_load.extend(["-Xclang", f"-plugin-arg-{plugin_name}", "-Xclang", arg])

    cmd.extend(plugin_load)

    # Add all processed files to the command
    for file_path in processed_files:
        # Convert to relative path from the git_root for clang
        try:
            relative_path = file_path.relative_to(git_root)
            cmd.append(str(relative_path))
        except ValueError:
            # If the file is not relative to git_root, use it as is
            cmd.append(str(file_path))

    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, cwd=git_root, capture_output=True, text=True)
        if result.stdout.strip():
            print(result.stdout)
        if result.stderr.strip() and result.returncode != 0:
            if verbose:
                print(f"[verbose] stderr: {result.stderr}")
            else:
                print(result.stderr, file=sys.stderr)
    except Exception as e:
        if verbose:
            print(f"[verbose] Error running clang plugin: {e}")
        sys.exit(1)

    # Process complete - no temporary files to clean up

# ----------------------------
# CLI
# ----------------------------
def main():
    parser = argparse.ArgumentParser(description="Extract content using LLVM plugin")
    parser.add_argument("plugin_name", help="LLVM plugin name to run")
    parser.add_argument("plugin_args", nargs="*", help="Arguments to pass to the plugin (e.g., class=Test, or --files file1.cpp file2.cpp)")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    parser.add_argument("--grep", help="Grep pattern to use for finding files")
    parser.add_argument("--files", nargs="*", help="Files to process (for compatibility)")
    args = parser.parse_args()

    git_root = get_git_root()

    # Separate plugin args from files
    plugin_args = []
    files = []
    
    # Use the --files argument if provided
    if args.files:
        files = args.files
    
    # Also check for --files in plugin_args (for backward compatibility)
    i = 0
    while i < len(args.plugin_args):
        arg = args.plugin_args[i]
        if arg == "--files" or arg == "--file":
            # Next arguments until the next flag are files
            i += 1
            while i < len(args.plugin_args) and not args.plugin_args[i].startswith("--"):
                files.append(args.plugin_args[i])
                i += 1
            continue
        else:
            plugin_args.append(arg)
            i += 1
    
    # If no files specified, try to find files using git grep with the grep pattern or first plugin arg
    if not files:
        search_term = args.grep
        if not search_term and plugin_args:
            # Use the first plugin arg as search term if available
            search_term = plugin_args[0].split('=')[-1] if '=' in plugin_args[0] else plugin_args[0]
        if search_term:
            files = git_grep_files(search_term, verbose=args.verbose)
            if not files:
                if args.verbose:
                    print(f"[verbose] No files found containing '{search_term}', using all C++ files")
                # Fallback to using all C++ files in the llvm directory
                llvm_dir = Path(__file__).resolve().parent.parent / "llvm"
                for ext in ["*.cpp", "*.cxx", "*.cc", "*.c", "*.h", "*.hpp", "*.hh", "*.hxx"]:
                    for file_path in llvm_dir.glob(ext):
                        if file_path.is_file():
                            files.append(str(file_path))
        else:
            # If no search term and no files specified, use all C++ files in the llvm directory
            if args.verbose:
                print(f"[verbose] No search term or files specified, using all C++ files")
            llvm_dir = Path(__file__).resolve().parent.parent / "llvm"
            for ext in ["*.cpp", "*.cxx", "*.cc", "*.c", "*.h", "*.hpp", "*.hh", "*.hxx"]:
                for file_path in llvm_dir.glob(ext):
                    if file_path.is_file():
                        files.append(str(file_path))

    extra_flags = read_clang_flags(git_root, verbose=args.verbose)
    extract_with_plugin(args.plugin_name, plugin_args, files, extra_flags, git_root, verbose=args.verbose)

if __name__ == "__main__":
    main()