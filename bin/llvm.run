#!/usr/bin/env python3
"""
Python replacement for `llvm.run` using LLVM plugin subprocess with:
- .clang/.clangd flags support
- Header TU handling
"""

import argparse
import subprocess
import sys

# Global array of essential clang flags to use by default
ESSENTIAL_CLANG_FLAGS = [
    "-triple", "x86_64-pc-linux-gnu",
    "-disable-free", 
    "-clear-ast-before-backend", 
    "-disable-llvm-verifier", 
    "-discard-value-names", 
    "-main-file-name", "null", 
    "-mrelocation-model", "pic", 
    "-pic-level", "2", 
    "-pic-is-pie", 
    "-mframe-pointer=all", 
    "-fmath-errno", 
    "-ffp-contract=on", 
    "-fno-rounding-math", 
    "-mconstructor-aliases", 
    # "-funwind-tables=2",  # Commented out to reduce warnings
    "-target-cpu", "x86-64", 
    "-tune-cpu", "generic", 
    "-debugger-tuning=gdb", 
    "-fdeprecated-macro", 
    "-ferror-limit", "19", 
    "-stack-protector", "2", 
    "-fgnuc-version=4.2.1",  # Commented out as it may cause issues
    "-fskip-odr-check-in-gmf", 
    "-fcxx-exceptions", 
    "-fexceptions", 
    "-faddrsig",
    # "-D__GCC_HAVE_DWARF2_CFI_ASM=1",  # Commented out for cleaner compilation
    # Specific warning suppression flags
    "-Wno-assume",  # For the assumption warning in webpp
    "-Wno-character-conversion",  # For the character conversion warning
    "-Wno-ignored-attributes",  # To suppress ignored attribute warnings
    "-Wno-deprecated-declarations"  # To suppress deprecated declarations warnings
]
from pathlib import Path
import tempfile
import shlex

# Global list of flags to exclude from clang compilation
EXCLUDE_FLAGS = [
    "--header-insertion=",  # Note: including the equals sign to match full flag patterns like --header-insertion=never
    "--limit-references",
    "--limit-results",
    "-W",
    "-Wall",
    "-Wextra",
    "-Wpedantic",
    "-Wno-unused-variable",
    "-Wno-infinite-recursion",
    "-Werror=implicit-function-declaration",
    "-Wshadow",
    "-Wno-shadow-field-in-constructor-modified",
    "-Wno-shadow-ivar",
    "-Wuninitialized",
    "-Wunused-label",
    "-Wunused-lambda-capture"
]

# ----------------------------
# Read valid clang flags from .clang/.clangd
# ----------------------------
def read_clang_flags(verbose=False):
    git_root = Path(".").resolve()
    while not (git_root / ".git").exists() and git_root.parent != git_root:
        git_root = git_root.parent
    flags = []

    for file_name in [".clang", ".clangd"]:
        path = git_root / file_name
        if path.exists():
            if verbose:
                print(f"[verbose] Reading clang flags from {path}")
            try:
                text = path.read_text()
                if file_name == ".clangd":
                    # Parse .clangd YAML-like format - look for flags in Add: array
                    in_add_line = False
                    for line in text.splitlines():
                        line = line.rstrip()
                        if line.strip().startswith("Add:"):
                            # Extract flags from the Add: line which should be in the format: Add: [-flag1, -flag2, ...]
                            # The format may be: Add: [-std=c++23, --limit-references, ...]
                            content = line.split("Add:", 1)[1].strip()
                            # Remove the opening bracket and closing bracket
                            content = content.strip('[]')
                            # Split by commas and process each flag
                            flag_items = [item.strip().strip('"\'') for item in content.split(',')]
                            for flag_item in flag_items:
                                flag_item = flag_item.strip()
                                if flag_item.startswith('-'):
                                    # Skip flags that should be excluded
                                    should_exclude = False
                                    for exclude_flag in EXCLUDE_FLAGS:
                                        if exclude_flag.endswith('='):
                                            # For flags with an equals sign, check if the flag starts with the base part
                                            base_flag = exclude_flag.rstrip('=')
                                            if flag_item.startswith(base_flag + '=') or flag_item == base_flag:
                                                should_exclude = True
                                                break
                                        else:
                                            # For flags without equals, use startswith
                                            if flag_item.startswith(exclude_flag):
                                                should_exclude = True
                                                break
                                    if not should_exclude:
                                        flags.append(flag_item)
                        elif line.strip().startswith("CompilationDatabase:"):
                            # Get compilation database path
                            comp_db_path = line.split(":", 1)[1].strip()
                            # Add compilation database flags if the directory exists
                            db_path = git_root / comp_db_path
                            if db_path.exists() and db_path.is_dir():
                                flags.append(f"-p={db_path}")
                else:  # .clang file - one flag per line
                    for line in text.splitlines():
                        line = line.strip()
                        if not line or line.startswith("#"):
                            continue
                        # Split by spaces
                        for token in shlex.split(line):
                            # Split comma-separated flags
                            subtokens = [t.strip() for t in token.split(",") if t.strip()]
                            for sub in subtokens:
                                # Skip flags that should be excluded
                                should_exclude = False
                                for exclude_flag in EXCLUDE_FLAGS:
                                    if exclude_flag.endswith('='):
                                        # For flags with an equals sign, check if the flag starts with the base part
                                        base_flag = exclude_flag.rstrip('=')
                                        if sub.startswith(base_flag + '=') or sub == base_flag:
                                            should_exclude = True
                                            break
                                    else:
                                        # For flags without equals, use startswith
                                        if sub.startswith(exclude_flag):
                                            should_exclude = True
                                            break
                                if not should_exclude:
                                    flags.append(sub)
            except Exception as e:
                if verbose:
                    print(f"[verbose] Failed reading {path}: {e}")
    return flags

# ----------------------------
# Find files using git grep
# ----------------------------
def git_grep_files(plugin_arg, verbose=False):
    cmd = ["git", "grep", "-l", plugin_arg, "--", "*.cpp", "*.cxx", "*.ixx", "*.cc", "*.h", "*.hpp"]
    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)
    files = result.stdout.strip().splitlines()
    if verbose:
        print(f"[verbose] Found files: {files}")
    return files

# ----------------------------
# Build the LLVM plugin shared library if it doesn't exist
# ----------------------------
def build_llvm_plugin(plugin_name, verbose=False):
    # The script is in bin directory, so llvm directory should be at ../llvm
    script_dir = Path(__file__).resolve().parent
    llvm_dir = script_dir.parent / "llvm"
    
    if not llvm_dir.exists():
        raise FileNotFoundError(f"LLVM directory not found at {llvm_dir}")
    
    # Look for source files that might contain the plugin implementation
    source_files = []
    
    for ext in ["*.cpp", "*.cxx", "*.cc"]:
        for file_path in llvm_dir.glob(ext):
            if file_path.is_file():
                source_files.append(file_path)
    
    if not source_files:
        raise FileNotFoundError(f"No source files found in llvm directory")
    
    # Look through source files to find one that registers the plugin name
    source_file = None
    for file_path in source_files:
        try:
            content = file_path.read_text()
            # Look for the plugin registration line in the source code
            if f'X("{plugin_name}",' in content or f'X( "{plugin_name}" ,' in content or \
               f'X( "{plugin_name}",' in content or f'X("{plugin_name}" ,' in content:
                source_file = file_path
                break
        except:
            continue  # Skip files that can't be read
    
    # If we didn't find a source file with exact registered name, look for plugin classes that might match
    if not source_file:
        for file_path in source_files:
            try:
                content = file_path.read_text()
                # Check for common plugin class patterns that might indicate the plugin supports this name
                if plugin_name in content:
                    # Look for class names that might be related to the plugin name
                    # For example, if plugin_name is "print-class", look for "PrintClassAction" class
                    plugin_class_name = ''.join(word.capitalize() for word in plugin_name.replace('-', '_').split('_')) + "Action"
                    if plugin_class_name in content:
                        source_file = file_path
                        break
            except:
                continue  # Skip files that can't be read
    
    if not source_file:
        raise FileNotFoundError(f"Plugin '{plugin_name}' not found in any source file in llvm directory. Available source files: {[f.name for f in source_files]}")
    
    lib_name = f"lib{plugin_name}.so"
    lib_path = llvm_dir / lib_name
    
    if not lib_path.exists():
        if verbose:
            print(f"[verbose] Building {lib_name} from {source_file}")
        # Build with proper include flags
        import subprocess as sp
        
        # Try to find clang installation location and get proper include paths
        try:
            # Find clang++ and use it to get system include paths
            result = sp.run(["clang++", "-v", "-E", "-x", "c++", "/dev/null", "-o", "/dev/null"], 
                           capture_output=True, text=True)
            if result.returncode == 0 and "#include <...> search starts here:" in result.stderr:
                lines = result.stderr.split('\n')
                in_includes = False
                include_flags = []
                for line in lines:
                    if "#include <...> search starts here:" in line:
                        in_includes = True
                        continue
                    elif "End of search list." in line:
                        in_includes = False
                        break
                    elif in_includes:
                        path = line.strip()
                        if path:
                            include_flags.append(f"-I{path}")
            else:
                include_flags = []
        except:
            include_flags = []
        
        build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC"]
        build_cmd.extend(include_flags)  # Add include flags from clang
        build_cmd.extend(["-lclang-cpp", str(source_file), "-o", str(lib_path)])
        
        result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
        if result.returncode != 0:
            if verbose:
                print(f"[verbose] First build attempt failed: {result.stderr}")
            # If the build fails, try finding clang installation using pkg-config or other methods
            clang_include_flags = []
            try:
                # Try to get flags from pkg-config
                pkg_result = sp.run(["pkg-config", "--cflags", "libclang"], capture_output=True, text=True)
                if pkg_result.returncode == 0:
                    pkg_flags = pkg_result.stdout.strip().split()
                    clang_include_flags.extend(pkg_flags)
            except:
                pass
            
            # If pkg-config didn't work, try common locations
            if not clang_include_flags:
                common_paths = [
                    "/usr/lib/clang/*/include",
                    "/usr/include/clang/*/include", 
                    "/usr/local/include/clang/*/include",
                    "/opt/homebrew/include/clang/*/include",
                    "/usr/include",
                ]
                
                import glob
                for pattern in common_paths:
                    matches = glob.glob(pattern)
                    if matches:
                        clang_include_flags.append(f"-I{matches[-1]}")  # Use the latest version
                        break
            
            build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC"]
            build_cmd.extend(clang_include_flags)
            build_cmd.extend(["-lclang-cpp", str(source_file), "-o", str(lib_path)])
            
            result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
            if result.returncode != 0:
                if verbose:
                    print(f"[verbose] Second build attempt failed: {result.stderr}")
                # Final fallback: just try the basic build
                build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC", str(source_file), "-o", str(lib_path)]
                result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
                if result.returncode != 0:
                    raise RuntimeError(f"Failed to build plugin: {result.stderr}")
    
    return lib_path

# ----------------------------
# Process files using LLVM plugin
# ----------------------------
def extract_with_plugin(plugin_name, plugin_args, files, extra_flags, verbose=False):
    try:
        # Build the plugin if needed
        lib_path = build_llvm_plugin(plugin_name, verbose=verbose)
    except Exception as e:
        print(f"Error: Could not build plugin '{plugin_name}': {e}", file=sys.stderr)
        sys.exit(1)
    
    # Check that the plugin file actually exists and is accessible
    if not lib_path.exists():
        print(f"Error: Plugin library {lib_path} was not created successfully", file=sys.stderr)
        sys.exit(1)
    
    # The script is in bin directory, so llvm directory should be at ../llvm
    script_dir = Path(__file__).resolve().parent
    llvm_dir = script_dir.parent / "llvm"
    
    if not llvm_dir.exists():
        raise FileNotFoundError(f"LLVM directory not found at {llvm_dir}")
    
    processed_files = []
    
    for file in files:
        path = Path(file)
        
        # The file path could be relative to the project root or llvm dir
        # First, check if it exists as-is (relative to current directory)
        if path.exists():
            abs_file_path = path.resolve()
        # Then check if it exists relative to the llvm directory
        elif (llvm_dir / path).exists():
            abs_file_path = (llvm_dir / path).resolve()
        else:
            # If it doesn't exist in either location, we'll still add it and let clang handle the error
            abs_file_path = path.resolve() if path.is_absolute() else (Path.cwd() / path).resolve()
        
        processed_files.append(abs_file_path)

    # clang command with LLVM plugin
    lib_name = f"lib{plugin_name}.so"
    # Use the absolute path to the library relative to the working directory
    lib_path_relative = llvm_dir / lib_name
    
    # Get default essential flags from our global array
    std_flags = ESSENTIAL_CLANG_FLAGS.copy()
    
    # Add the debug compilation directory based on the working directory
    working_dir = str(Path.cwd())
    std_flags.extend([
        "-fdebug-compilation-dir", working_dir
    ])
    
    # Add resource directory (can be detected or default)
    import subprocess as sp
    try:
        # Try to get resource directory from clang
        result = sp.run(["clang", "-print-resource-dir"], capture_output=True, text=True)
        if result.returncode == 0 and result.stdout.strip():
            resource_dir = result.stdout.strip()
            if resource_dir:
                # Replace the resource-dir in std_flags if we found one
                if "-resource-dir" in std_flags:
                    idx = std_flags.index("-resource-dir")
                    if idx + 1 < len(std_flags):
                        std_flags[idx + 1] = resource_dir
                else:
                    std_flags.extend(["-resource-dir", resource_dir])
        else:
            # If we can't get the resource dir, just keep the default one
            pass
    except:
        # If all methods fail, use the default resource-dir from ESSENTIAL_CLANG_FLAGS
        pass
    
    # Add system include paths (get them from clang -v if possible)
    include_flags = []
    try:
        result = sp.run(["clang++", "-v", "-E", "-x", "c++", "/dev/null", "-o", "/dev/null"], 
                       capture_output=True, text=True)
        
        if result.returncode == 0:
            lines = result.stderr.split('\n')
            in_includes = False
            for line in lines:
                if "#include <...> search starts here:" in line:
                    in_includes = True
                    continue
                elif "End of search list." in line:
                    in_includes = False
                    break
                elif in_includes:
                    path = line.strip()
                    if path:
                        include_flags.extend(["-internal-isystem", path])
    except:
        pass  # If this fails, include_flags remains empty
    
    std_flags.extend(include_flags)
    
    # Remove any potential duplicate -cc1 that might have been included from clang's output
    # This could happen if -cc1 was in the extracted default flags
    cleaned_std_flags = []
    for flag in std_flags:
        if flag != "-cc1":  # Remove any -cc1 that might have been captured
            cleaned_std_flags.append(flag)
    
    cmd = ["clang", "-cc1"] + cleaned_std_flags
    
    # Add extra flags (from .clang/.clangd) but remove duplicates to prevent issues like "-std=c++23 -std=c++23" 
    # Placing these early to ensure language settings like -std=c++23 are applied before file processing
    unique_extra_flags = []
    seen_flags = set()
    i = 0
    while i < len(extra_flags):
        flag = extra_flags[i]
        if flag in ['-std', '-I', '-isystem', '-include', '-D', '-L', '-l']:
            # This is a flag that takes an argument, so combine with next value
            if i + 1 < len(extra_flags):
                combined_flag = f"{flag} {extra_flags[i+1]}"
                if combined_flag not in seen_flags:
                    unique_extra_flags.extend([flag, extra_flags[i+1]])
                    seen_flags.add(combined_flag)
                i += 2
            else:
                if flag not in seen_flags:
                    unique_extra_flags.append(flag)
                    seen_flags.add(flag)
                i += 1
        elif flag.startswith(('-std=', '-I', '-isystem', '-include', '-D', '-L', '-l')):
            # This is a flag=value format (like -std=c++23, -I./, etc.)
            if flag not in seen_flags:
                unique_extra_flags.append(flag)
                seen_flags.add(flag)
        else:
            # Regular flag
            if flag not in seen_flags:
                unique_extra_flags.append(flag)
                seen_flags.add(flag)
        i += 1
    
    cmd.extend(unique_extra_flags)
    
    # Add plugin loading and plugin arguments
    cmd.extend(["-load", f"./{lib_name}", "-plugin", plugin_name])

    # Add all plugin arguments directly
    for arg in plugin_args:
        if '=' in arg:
            # Split plugin arg like "class=Test" into "-plugin-arg-pluginname" and "class=Test"
            cmd.extend([f"-plugin-arg-{plugin_name}", arg])
        else:
            cmd.extend([f"-plugin-arg-{plugin_name}", arg])

    # Add all processed files to the command
    for file_path in processed_files:
        # Convert to relative path from the llvm directory for clang
        try:
            relative_path = file_path.relative_to(llvm_dir)
            cmd.append(str(relative_path))
        except ValueError:
            # If the file is not relative to llvm_dir, use it as is
            cmd.append(str(file_path))

    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, cwd=llvm_dir, capture_output=True, text=True)
        if result.stdout.strip():
            print(result.stdout)
        if result.stderr.strip() and result.returncode != 0:
            if verbose:
                print(f"[verbose] stderr: {result.stderr}")
            else:
                print(result.stderr, file=sys.stderr)
    except Exception as e:
        if verbose:
            print(f"[verbose] Error running clang plugin: {e}")
        sys.exit(1)

    # Process complete - no temporary files to clean up

# ----------------------------
# CLI
# ----------------------------
def main():
    parser = argparse.ArgumentParser(description="Extract content using LLVM plugin")
    parser.add_argument("plugin_name", help="LLVM plugin name to run")
    parser.add_argument("plugin_args", nargs="*", help="Arguments to pass to the plugin (e.g., class=Test, or --files file1.cpp file2.cpp)")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    parser.add_argument("--grep", help="Grep pattern to use for finding files")
    parser.add_argument("--files", nargs="*", help="Files to process (for compatibility)")
    args = parser.parse_args()

    # Separate plugin args from files
    plugin_args = []
    files = []
    
    # Use the --files argument if provided
    if args.files:
        files = args.files
    
    # Also check for --files in plugin_args (for backward compatibility)
    i = 0
    while i < len(args.plugin_args):
        arg = args.plugin_args[i]
        if arg == "--files" or arg == "--file":
            # Next arguments until the next flag are files
            i += 1
            while i < len(args.plugin_args) and not args.plugin_args[i].startswith("--"):
                files.append(args.plugin_args[i])
                i += 1
            continue
        else:
            plugin_args.append(arg)
            i += 1
    
    # If no files specified, try to find files using git grep with the grep pattern or first plugin arg
    if not files:
        search_term = args.grep
        if not search_term and plugin_args:
            # Use the first plugin arg as search term if available
            search_term = plugin_args[0].split('=')[-1] if '=' in plugin_args[0] else plugin_args[0]
        if search_term:
            files = git_grep_files(search_term, verbose=args.verbose)
            if not files:
                if args.verbose:
                    print(f"[verbose] No files found containing '{search_term}', using all C++ files")
                # Fallback to using all C++ files in the llvm directory
                llvm_dir = Path(__file__).resolve().parent.parent / "llvm"
                for ext in ["*.cpp", "*.cxx", "*.cc", "*.c", "*.h", "*.hpp", "*.hh", "*.hxx"]:
                    for file_path in llvm_dir.glob(ext):
                        if file_path.is_file():
                            files.append(str(file_path.name))
        else:
            # If no search term and no files specified, use all C++ files in the llvm directory
            if args.verbose:
                print(f"[verbose] No search term or files specified, using all C++ files")
            llvm_dir = Path(__file__).resolve().parent.parent / "llvm"
            for ext in ["*.cpp", "*.cxx", "*.cc", "*.c", "*.h", "*.hpp", "*.hh", "*.hxx"]:
                for file_path in llvm_dir.glob(ext):
                    if file_path.is_file():
                        files.append(str(file_path.name))

    extra_flags = read_clang_flags(verbose=args.verbose)
    extract_with_plugin(args.plugin_name, plugin_args, files, extra_flags, verbose=args.verbose)

if __name__ == "__main__":
    main()