#!/usr/bin/env python3
"""
Python replacement for `llvm.run` using LLVM plugin subprocess with:
- .clang/.clangd flags support
- Header TU handling
"""

import argparse
import subprocess
import sys
from pathlib import Path
import tempfile
import shlex

# ----------------------------
# Read valid clang flags from .clang/.clangd
# ----------------------------
def read_clang_flags(verbose=False):
    git_root = Path(".").resolve()
    while not (git_root / ".git").exists() and git_root.parent != git_root:
        git_root = git_root.parent
    flags = []

    for file_name in [".clang", ".clangd"]:
        path = git_root / file_name
        if path.exists():
            if verbose:
                print(f"[verbose] Reading clang flags from {path}")
            try:
                text = path.read_text()
                if file_name == ".clangd":
                    # Parse .clangd YAML-like format - look for flags in Add: array
                    in_add_line = False
                    for line in text.splitlines():
                        line = line.rstrip()
                        if line.strip().startswith("Add:"):
                            # Extract flags from the Add: line which should be in the format: Add: [-flag1, -flag2, ...]
                            # The format may be: Add: [-std=c++23, --limit-references, ...]
                            content = line.split("Add:", 1)[1].strip()
                            # Remove the opening bracket and closing bracket
                            content = content.strip('[]')
                            # Split by commas and process each flag
                            flag_items = [item.strip().strip('"\'') for item in content.split(',')]
                            for flag_item in flag_items:
                                flag_item = flag_item.strip()
                                if flag_item.startswith('-'):
                                    flags.append(flag_item)
                        elif line.strip().startswith("CompilationDatabase:"):
                            # Get compilation database path
                            comp_db_path = line.split(":", 1)[1].strip()
                            # Add compilation database flags if the directory exists
                            db_path = git_root / comp_db_path
                            if db_path.exists() and db_path.is_dir():
                                flags.append(f"-p={db_path}")
                else:  # .clang file - one flag per line
                    for line in text.splitlines():
                        line = line.strip()
                        if not line or line.startswith("#"):
                            continue
                        # Split by spaces
                        for token in shlex.split(line):
                            # Split comma-separated flags
                            subtokens = [t.strip() for t in token.split(",") if t.strip()]
                            for sub in subtokens:
                                # Keep only valid clang CLI flags
                                if sub.startswith("-") and not sub.startswith("--header-insertion") and not sub.startswith("--limit"):
                                    flags.append(sub)
            except Exception as e:
                if verbose:
                    print(f"[verbose] Failed reading {path}: {e}")
    return flags

# ----------------------------
# Find files using git grep
# ----------------------------
def git_grep_files(plugin_arg, verbose=False):
    cmd = ["git", "grep", "-l", plugin_arg, "--", "*.cpp", "*.cxx", "*.ixx", "*.cc", "*.h", "*.hpp"]
    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)
    files = result.stdout.strip().splitlines()
    if verbose:
        print(f"[verbose] Found files: {files}")
    return files

# ----------------------------
# Build the LLVM plugin shared library if it doesn't exist
# ----------------------------
def build_llvm_plugin(plugin_name, verbose=False):
    # The script is in bin directory, so llvm directory should be at ../llvm
    script_dir = Path(__file__).resolve().parent
    llvm_dir = script_dir.parent / "llvm"
    
    if not llvm_dir.exists():
        raise FileNotFoundError(f"LLVM directory not found at {llvm_dir}")
    
    # Look for source files that might contain the plugin implementation
    source_files = []
    
    for ext in ["*.cpp", "*.cxx", "*.cc"]:
        for file_path in llvm_dir.glob(ext):
            if file_path.is_file():
                source_files.append(file_path)
    
    if not source_files:
        raise FileNotFoundError(f"No source files found in llvm directory")
    
    # Look through source files to find one that registers the plugin name
    source_file = None
    for file_path in source_files:
        try:
            content = file_path.read_text()
            # Look for the plugin registration line in the source code
            if f'X("{plugin_name}",' in content or f'X( "{plugin_name}" ,' in content or \
               f'X( "{plugin_name}",' in content or f'X("{plugin_name}" ,' in content:
                source_file = file_path
                break
        except:
            continue  # Skip files that can't be read
    
    # If we didn't find a source file with exact registered name, look for plugin classes that might match
    if not source_file:
        for file_path in source_files:
            try:
                content = file_path.read_text()
                # Check for common plugin class patterns that might indicate the plugin supports this name
                if plugin_name in content:
                    # Look for class names that might be related to the plugin name
                    # For example, if plugin_name is "print-class", look for "PrintClassAction" class
                    plugin_class_name = ''.join(word.capitalize() for word in plugin_name.replace('-', '_').split('_')) + "Action"
                    if plugin_class_name in content:
                        source_file = file_path
                        break
            except:
                continue  # Skip files that can't be read
    
    if not source_file:
        raise FileNotFoundError(f"Plugin '{plugin_name}' not found in any source file in llvm directory. Available source files: {[f.name for f in source_files]}")
    
    lib_name = f"lib{plugin_name}.so"
    lib_path = llvm_dir / lib_name
    
    if not lib_path.exists():
        if verbose:
            print(f"[verbose] Building {lib_name} from {source_file}")
        # Build with proper include flags
        import subprocess as sp
        
        # Try to find clang installation location and get proper include paths
        try:
            # Find clang++ and use it to get system include paths
            result = sp.run(["clang++", "-v", "-E", "-x", "c++", "/dev/null", "-o", "/dev/null"], 
                           capture_output=True, text=True)
            if result.returncode == 0 and "#include <...> search starts here:" in result.stderr:
                lines = result.stderr.split('\n')
                in_includes = False
                include_flags = []
                for line in lines:
                    if "#include <...> search starts here:" in line:
                        in_includes = True
                        continue
                    elif "End of search list." in line:
                        in_includes = False
                        break
                    elif in_includes:
                        path = line.strip()
                        if path:
                            include_flags.append(f"-I{path}")
            else:
                include_flags = []
        except:
            include_flags = []
        
        build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC"]
        build_cmd.extend(include_flags)  # Add include flags from clang
        build_cmd.extend(["-lclang-cpp", str(source_file), "-o", str(lib_path)])
        
        result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
        if result.returncode != 0:
            if verbose:
                print(f"[verbose] First build attempt failed: {result.stderr}")
            # If the build fails, try finding clang installation using pkg-config or other methods
            clang_include_flags = []
            try:
                # Try to get flags from pkg-config
                pkg_result = sp.run(["pkg-config", "--cflags", "libclang"], capture_output=True, text=True)
                if pkg_result.returncode == 0:
                    pkg_flags = pkg_result.stdout.strip().split()
                    clang_include_flags.extend(pkg_flags)
            except:
                pass
            
            # If pkg-config didn't work, try common locations
            if not clang_include_flags:
                common_paths = [
                    "/usr/lib/clang/*/include",
                    "/usr/include/clang/*/include", 
                    "/usr/local/include/clang/*/include",
                    "/opt/homebrew/include/clang/*/include",
                    "/usr/include",
                ]
                
                import glob
                for pattern in common_paths:
                    matches = glob.glob(pattern)
                    if matches:
                        clang_include_flags.append(f"-I{matches[-1]}")  # Use the latest version
                        break
            
            build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC"]
            build_cmd.extend(clang_include_flags)
            build_cmd.extend(["-lclang-cpp", str(source_file), "-o", str(lib_path)])
            
            result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
            if result.returncode != 0:
                if verbose:
                    print(f"[verbose] Second build attempt failed: {result.stderr}")
                # Final fallback: just try the basic build
                build_cmd = ["clang++", "-std=c++26", "-shared", "-fPIC", str(source_file), "-o", str(lib_path)]
                result = subprocess.run(build_cmd, cwd=llvm_dir, capture_output=True, text=True)
                if result.returncode != 0:
                    raise RuntimeError(f"Failed to build plugin: {result.stderr}")
    
    return lib_path

# ----------------------------
# Process files using LLVM plugin
# ----------------------------
def extract_with_plugin(plugin_name, plugin_args, files, extra_flags, verbose=False):
    try:
        # Build the plugin if needed
        lib_path = build_llvm_plugin(plugin_name, verbose=verbose)
    except Exception as e:
        print(f"Error: Could not build plugin '{plugin_name}': {e}", file=sys.stderr)
        sys.exit(1)
    
    # Check that the plugin file actually exists and is accessible
    if not lib_path.exists():
        print(f"Error: Plugin library {lib_path} was not created successfully", file=sys.stderr)
        sys.exit(1)
    
    # The script is in bin directory, so llvm directory should be at ../llvm
    script_dir = Path(__file__).resolve().parent
    llvm_dir = script_dir.parent / "llvm"
    
    if not llvm_dir.exists():
        raise FileNotFoundError(f"LLVM directory not found at {llvm_dir}")
    
    # Process header files with temporary TUs
    processed_files = []
    temp_files = []
    
    for file in files:
        path = Path(file)
        
        # The file path could be relative to the project root or llvm dir
        # First, check if it exists as-is (relative to current directory)
        if path.exists():
            abs_file_path = path.resolve()
        # Then check if it exists relative to the llvm directory
        elif (llvm_dir / path).exists():
            abs_file_path = (llvm_dir / path).resolve()
        else:
            # If it doesn't exist in either location, we'll still add it and let clang handle the error
            abs_file_path = path.resolve() if path.is_absolute() else (Path.cwd() / path).resolve()
        
        # Handle headers with temporary TU
        if path.suffix in ['.h', '.hpp', '.hh', '.hxx', '.ixx']:
            tu_file = tempfile.NamedTemporaryFile(suffix=".cpp", delete=False)
            # Use absolute path for the header inclusion
            tu_file.write(f'#include "{abs_file_path}"\n'.encode())
            tu_file.close()
            processed_files.append(Path(tu_file.name))
            temp_files.append(Path(tu_file.name))
            if verbose:
                print(f"[verbose] Created temporary TU: {tu_file.name}")
        else:
            processed_files.append(abs_file_path)

    # clang command with LLVM plugin
    lib_name = f"lib{plugin_name}.so"
    # Use the absolute path to the library relative to the working directory
    lib_path_relative = llvm_dir / lib_name
    
    cmd = ["clang", "-cc1", "-load", f"./{lib_name}", "-plugin", plugin_name]
    
    # Add all plugin arguments directly
    for arg in plugin_args:
        if '=' in arg:
            # Split plugin arg like "class=Test" into "-plugin-arg-pluginname" and "class=Test"
            cmd.extend([f"-plugin-arg-{plugin_name}", arg])
        else:
            cmd.extend([f"-plugin-arg-{plugin_name}", arg])

    # Add all processed files to the command
    for file_path in processed_files:
        # Convert to relative path from the llvm directory for clang
        try:
            relative_path = file_path.relative_to(llvm_dir)
            cmd.append(str(relative_path))
        except ValueError:
            # If the file is not relative to llvm_dir, use it as is
            cmd.append(str(file_path))

    cmd.extend(extra_flags)

    if verbose:
        print(f"[verbose] Running: {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, cwd=llvm_dir, capture_output=True, text=True)
        if result.stdout.strip():
            print(result.stdout)
        if result.stderr.strip() and result.returncode != 0:
            if verbose:
                print(f"[verbose] stderr: {result.stderr}")
            else:
                print(result.stderr, file=sys.stderr)
    except Exception as e:
        if verbose:
            print(f"[verbose] Error running clang plugin: {e}")
        sys.exit(1)

    # Clean up temporary TU files
    for temp_file in temp_files:
        temp_file.unlink()

# ----------------------------
# CLI
# ----------------------------
def main():
    parser = argparse.ArgumentParser(description="Extract content using LLVM plugin")
    parser.add_argument("plugin_name", help="LLVM plugin name to run")
    parser.add_argument("plugin_args", nargs="*", help="Arguments to pass to the plugin (e.g., class=Test, or --files file1.cpp file2.cpp)")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    parser.add_argument("--grep", help="Grep pattern to use for finding files")
    parser.add_argument("--files", nargs="*", help="Files to process (for compatibility)")
    args = parser.parse_args()

    # Separate plugin args from files
    plugin_args = []
    files = []
    
    # Use the --files argument if provided
    if args.files:
        files = args.files
    
    # Also check for --files in plugin_args (for backward compatibility)
    i = 0
    while i < len(args.plugin_args):
        arg = args.plugin_args[i]
        if arg == "--files" or arg == "--file":
            # Next arguments until the next flag are files
            i += 1
            while i < len(args.plugin_args) and not args.plugin_args[i].startswith("--"):
                files.append(args.plugin_args[i])
                i += 1
            continue
        else:
            plugin_args.append(arg)
            i += 1
    
    # If no files specified, try to find files using git grep with the grep pattern or first plugin arg
    if not files:
        search_term = args.grep
        if not search_term and plugin_args:
            # Use the first plugin arg as search term if available
            search_term = plugin_args[0].split('=')[-1] if '=' in plugin_args[0] else plugin_args[0]
        if search_term:
            files = git_grep_files(search_term, verbose=args.verbose)
            if not files:
                if args.verbose:
                    print(f"[verbose] No files found containing '{search_term}', using all C++ files")
                # Fallback to using all C++ files in the llvm directory
                llvm_dir = Path(__file__).resolve().parent.parent / "llvm"
                for ext in ["*.cpp", "*.cxx", "*.cc", "*.c", "*.h", "*.hpp", "*.hh", "*.hxx"]:
                    for file_path in llvm_dir.glob(ext):
                        if file_path.is_file():
                            files.append(str(file_path.name))
        else:
            # If no search term and no files specified, use all C++ files in the llvm directory
            if args.verbose:
                print(f"[verbose] No search term or files specified, using all C++ files")
            llvm_dir = Path(__file__).resolve().parent.parent / "llvm"
            for ext in ["*.cpp", "*.cxx", "*.cc", "*.c", "*.h", "*.hpp", "*.hh", "*.hxx"]:
                for file_path in llvm_dir.glob(ext):
                    if file_path.is_file():
                        files.append(str(file_path.name))

    extra_flags = read_clang_flags(verbose=args.verbose)
    extract_with_plugin(args.plugin_name, plugin_args, files, extra_flags, verbose=args.verbose)

if __name__ == "__main__":
    main()