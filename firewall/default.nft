#!/sbin/nft -f

define local_network = { 192.168.88.0/16, 10.1.1.0/24 }
define skip_vpn_mark = 0xe1f1 # NordVPN default vpn mark used in iproute2
define multicast_ips = 224.0.0.0-239.255.255.255

flush ruleset

table inet filter {
    counter everything { comment "All IN/OUT" }
    counter all.in { comment "All IN" }
    counter all.out { comment "All OUT" }
    counter local { comment "All Local IN/OUT" }
    counter local.in { comment "All Local IN" }
    counter local.out { comment "All Local Out"}
    counter internet { comment "All Non-Local IN/OUT" }
    counter internet.in { comment "All Non-Local IN" }
    counter internet.out { comment "All Non-Local Out"}
    counter filter.loopback { comment "Loopback" }
    counter filter.state { comment "Established, Related, Invalid connection states" }
    counter filter.okayports { comment "All of the Okay Ports" }
    counter filter.okayprotocols { comment "All of the Okay Protocols" }
    counter filter.igmp { comment "IGMP" }
    counter filter.ipv4.icmp { comment "IPv4 ICMP" }
    counter filter.ipv6.icmp { comment "IPv6 ICMP" }
    counter filter.drop { comment "Packets that weren't allowed" }
    counter forward.to.local { comment "Forward To Local Network from anywhere" }
    counter forward.from.local { comment "Forward From Local Network to anywhere" }
    counter forward.drop { comment "Forward dropped" }

    set okprotos {
        type inet_service
        counter
        elements = { # look at /etc/services
            smtp,          # Mail Server for router
            pop3,          # Mail Server for phone
            sftp,          # Files
            domain,        # DNS
            ssh,
            rfb,           # VNC
            ms-wbt-server  # RDP
        }
    }
    set okports {
        type inet_proto . inet_service
        counter
        elements = {
            tcp . 4713      # PULSE_SERVER=tcp:machine:4713 allow input audio
        }
    }

    chain inbound {
        type filter hook prerouting priority raw
        policy accept
        counter name everything
        counter name all.in
        ip saddr $local_network counter name local
        ip saddr $local_network counter name local.in
        ip saddr != $local_network counter name internet
        ip saddr != $local_network counter name internet.in
    }

    chain outbound {
        type filter hook postrouting priority 300
        policy accept
        counter name everything
        counter name all.out
        ip daddr $local_network counter name local
        ip daddr $local_network counter name local.out
        ip daddr != $local_network counter name internet.out
        ip daddr != $local_network counter name internet
    }

    chain input {
        type filter hook input priority filter
        policy drop
        
        ct state vmap {
            established: accept,
            related: accept,
            invalid: drop
        } counter name filter.state

        iifname lo counter name filter.loopback accept comment "allow loopback"
        # iif != lo ip daddr 127.0.0.1/8 counter drop comment "drop connections to loopback not comming from loopback"
        # iif != lo ip6 daddr ::1/128 counter drop comment "drop connections to loopback not comming from loopback"

        ip saddr $local_network meta l4proto . th dport @okports counter name filter.okayports accept comment "allow ports"
        ip saddr $local_network th dport @okprotos counter name filter.okayprotocols accept comment "allow protocols"

        ip protocol icmp counter name filter.ipv4.icmp accept comment "allow ICMP"
        meta l4proto ipv6-icmp counter name filter.ipv6.icmp accept comment "allow ICMPv6"

        ip protocol igmp counter name filter.igmp accept comment "allow IGMP"
        # ip daddr $multicast_ips counter accept comment "allow multicast ips (for winbox)"

        # pkttype host limit rate 5/second counter name filter.ratelimit reject with icmpx type admin-prohibited comment "rate limit"

        counter name filter.drop log prefix "nft#in-dropped " group 0 comment "count dropped packets"
    }

    chain forward {
        type filter hook forward priority filter
        policy drop

        ip saddr $local_network counter name forward.to.local accept comment "to/from local network"
        ip daddr $local_network counter name forward.from.local accept comment "to/from local network"

        counter name forward.drop comment "count dropped packets"
    }
}

table inet mangle {
    counter skip.all { comment "All packets that skipped the VPN" }
    counter skip.manuals { comment "Manually specified IPs that skipped the VPN" }
    counter skip.ignored { comment "IPs of domain names that got to skip the VPN" }
    counter skip.geoips4 { comment "IPs of countries" }
    counter skip.multicast { comment "Multicast IPs that marked to skip VPN" }
    counter skip.prerouting { comment "Input from WAN (not local network)" }
    counter skip.output { comment "Output from our own system (doesn't include forwards)" }

    # Country IPs go here
    set geoips4 {
        type ipv4_addr
        flags interval # enable CIDR and ranges
    }

    # Ignored set of IPs of domain names
    set ignored {
        typeof ip daddr
    }

    # Manual list of IPs/CIDRs to ignore
    set skipips {
        type ipv4_addr
        flags interval # enable CIDR and ranges
        elements = {
            $multicast_ips
        }
    }

    chain marker {
        # This is the chain that defines how the packets that are
        # supposed to not go through the VPN is going to not go to VPN
        #
        # Currently, we just mark the packet
        counter name skip.all mark set $skip_vpn_mark
    }

    chain skipper {
        # Here we define the packets that should be skip the VPN
        ip daddr @skipips counter name skip.manuals goto marker
        ip daddr @ignored counter name skip.ignored goto marker
        ip daddr @geoips4 counter name skip.geoips4 goto marker
        meta pkttype multicast counter name skip.multicast goto marker
    }

    # chain ingress {
    #     type filter hook ingress device enp2s0 priority raw
    #     goto skipper
    # }

    chain prerouting {
        type filter hook prerouting priority raw
        policy accept
        ip daddr $local_network accept
        counter name skip.prerouting jump skipper
    }

    chain output {
        type route hook output priority raw
        policy accept;
        ip daddr $local_network accept
        counter name skip.output jump skipper
    }
}

table inet nat {
    counter nat.masquerade { comment "NAT performed on them" }
    counter nat.skip { comment "NAT performed marked packets" }

    chain prerouting {
        type nat hook prerouting priority dstnat
    }

    chain input {
        type nat hook input priority filter
    }

    chain output {
        type nat hook output priority filter
    }

    chain postrouting {
        type nat hook postrouting priority srcnat

        meta mark $skip_vpn_mark counter name nat.skip masquerade comment "nat marked packets"
        ip saddr $local_network counter name nat.masquerade masquerade comment "nat everything"
    }
}
